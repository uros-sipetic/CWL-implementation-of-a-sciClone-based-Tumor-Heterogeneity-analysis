{
  "sbg:canvas_x": -301,
  "sbg:revisionsInfo": [
    {
      "sbg:revisionNotes": "Copy of uros_sipetic/bms-tumor-heterogeneity-dev/sciclone-workflow/32",
      "sbg:modifiedBy": "uros_sipetic",
      "sbg:modifiedOn": 1485959785,
      "sbg:revision": 0
    },
    {
      "sbg:revisionNotes": "Copy of uros_sipetic/bms-tumor-heterogeneity-dev/sciclone-workflow/33",
      "sbg:modifiedBy": "uros_sipetic",
      "sbg:modifiedOn": 1485960747,
      "sbg:revision": 1
    },
    {
      "sbg:revisionNotes": "Copy of uros_sipetic/bms-tumor-heterogeneity-dev/sciclone-workflow/34",
      "sbg:modifiedBy": "uros_sipetic",
      "sbg:modifiedOn": 1486045037,
      "sbg:revision": 2
    },
    {
      "sbg:revisionNotes": "Copy of uros_sipetic/bms-tumor-heterogeneity-dev/sciclone-workflow/35",
      "sbg:modifiedBy": "uros_sipetic",
      "sbg:modifiedOn": 1486045236,
      "sbg:revision": 3
    },
    {
      "sbg:revisionNotes": "Copy of uros_sipetic/bms-tumor-heterogeneity-dev/sciclone-workflow/36",
      "sbg:modifiedBy": "uros_sipetic",
      "sbg:modifiedOn": 1486045960,
      "sbg:revision": 4
    },
    {
      "sbg:revisionNotes": "Copy of uros_sipetic/bms-tumor-heterogeneity-dev/sciclone-workflow/37",
      "sbg:modifiedBy": "uros_sipetic",
      "sbg:modifiedOn": 1486046606,
      "sbg:revision": 5
    },
    {
      "sbg:revisionNotes": "Copy of uros_sipetic/bms-tumor-heterogeneity-dev/sciclone-workflow/38",
      "sbg:modifiedBy": "uros_sipetic",
      "sbg:modifiedOn": 1486052636,
      "sbg:revision": 6
    },
    {
      "sbg:revisionNotes": "Copy of uros_sipetic/bms-tumor-heterogeneity-dev/sciclone-workflow/39",
      "sbg:modifiedBy": "uros_sipetic",
      "sbg:modifiedOn": 1486056423,
      "sbg:revision": 7
    },
    {
      "sbg:revisionNotes": "Copy of uros_sipetic/bms-tumor-heterogeneity-dev/sciclone-workflow/40",
      "sbg:modifiedBy": "uros_sipetic",
      "sbg:modifiedOn": 1486063541,
      "sbg:revision": 8
    },
    {
      "sbg:revisionNotes": "Copy of uros_sipetic/bms-tumor-heterogeneity-dev/sciclone-workflow/48",
      "sbg:modifiedBy": "uros_sipetic",
      "sbg:modifiedOn": 1493230311,
      "sbg:revision": 9
    },
    {
      "sbg:revisionNotes": "Copy of uros_sipetic/bms-tumor-heterogeneity-dev/sciclone-workflow/49",
      "sbg:modifiedBy": "uros_sipetic",
      "sbg:modifiedOn": 1493230742,
      "sbg:revision": 10
    },
    {
      "sbg:revisionNotes": "Copy of uros_sipetic/bms-tumor-heterogeneity-dev/sciclone-workflow/50",
      "sbg:modifiedBy": "uros_sipetic",
      "sbg:modifiedOn": 1494245664,
      "sbg:revision": 11
    },
    {
      "sbg:revisionNotes": "Copy of uros_sipetic/bms-tumor-heterogeneity-dev/sciclone-workflow/51",
      "sbg:modifiedBy": "uros_sipetic",
      "sbg:modifiedOn": 1494246148,
      "sbg:revision": 12
    },
    {
      "sbg:revisionNotes": "Copy of uros_sipetic/bms-tumor-heterogeneity-dev/sciclone-workflow/52",
      "sbg:modifiedBy": "uros_sipetic",
      "sbg:modifiedOn": 1494247364,
      "sbg:revision": 13
    },
    {
      "sbg:revisionNotes": "Copy of uros_sipetic/bms-tumor-heterogeneity-dev/sciclone-workflow/53",
      "sbg:modifiedBy": "uros_sipetic",
      "sbg:modifiedOn": 1494348998,
      "sbg:revision": 14
    },
    {
      "sbg:revisionNotes": "Copy of uros_sipetic/bms-tumor-heterogeneity-dev/sciclone-workflow/54",
      "sbg:modifiedBy": "uros_sipetic",
      "sbg:modifiedOn": 1494435789,
      "sbg:revision": 15
    },
    {
      "sbg:revisionNotes": "Copy of uros_sipetic/bms-tumor-heterogeneity-dev/sciclone-workflow/55",
      "sbg:modifiedBy": "uros_sipetic",
      "sbg:modifiedOn": 1494438012,
      "sbg:revision": 16
    },
    {
      "sbg:revisionNotes": "Copy of uros_sipetic/bms-tumor-heterogeneity-dev/sciclone-workflow/56",
      "sbg:modifiedBy": "uros_sipetic",
      "sbg:modifiedOn": 1494516394,
      "sbg:revision": 17
    }
  ],
  "sbg:projectName": "BMS Tumor Heterogeneity",
  "description": "This workflow performs tumor sub-clonality and tumor heterogeneity analysis using SciClone, ClonEvol and Fishplot R packages. \n\n###Required inputs\nThis workflow has **one** required inputs:\n\n1. VCF file (ID: *input_files*) - VCF files with called variants\n\n###Optional inputs\nThis workflow has **four** optional inputs:\n\n1. Tumor BAM files (ID: *bams*) - aligned BAM files from sequenced tumor samples\n\n2. Copy number calls (ID: *copyNumberCalls*) - file containing copy number variation data\n\n3. GTF file (ID: *gtf*) - gene annotation file\n\n4. Known cancer genes (ID: *known\\_cancer\\_genes*) - database with known cancer genes, like COSMIC\n\n###Outputs\nThis workflow generates **five** outputs:\n\n1. SciClone plots (ID: *sciclone_plots*) - all plots generated by the SciClone tool.\n\n2. ClonEvol plots (ID: *clonevol_plots*) - all plots generated by the ClonEvol tool.\n\n3. Fishplot plots (ID: *fishplot_plots*) - all plots generated by the Fishplot tool.\n\n4. SciClone clusters summary (ID: *clusterSummary*) - information about SciClone clusters (namely centroid data). \n\n5. Estimated tumor purity (ID: *purity*) - Estimated sample tumor purity\n\n###Common issues###\n1. If multiple samples are provided (in the form of multiple VCF files), accompanying BAM files for each sample should also be provided. In the case of only one sample, a BAM file is not required.\n2. Under the SciClone parameters, please specify the correct Copy-number caller used to infer the input copy number data (if provided).\n3. Fishplot currently might not output any plots, if certain requirements are not satisfied in the ClonEvol step.\n4. A GTF file and a known cancer database (like COSMIC) are optional inputs, as they are used for generating additional plots by the ClonEvol tool.",
  "sbg:canvas_zoom": 0.7499999999999998,
  "sbg:copyOf": "uros_sipetic/bms-tumor-heterogeneity-dev/sciclone-workflow/56",
  "sbg:createdBy": "uros_sipetic",
  "sbg:sbgMaintained": false,
  "steps": [
    {
      "sbg:x": 1595.94775390625,
      "outputs": [
        {
          "id": "#ClonEvol_0_1.clonevol_plots"
        },
        {
          "id": "#ClonEvol_0_1.clonevol_model"
        }
      ],
      "id": "#ClonEvol_0_1",
      "sbg:y": 323.22821044921875,
      "run": {
        "sbg:cmdPreview": "python add_known_cancer_genes.py  -s /path/to/test.sciclone.clusters  && Rscript ClonEvol.R  && mv test.sciclone.clusters.ClonEvol.output/model.pdf test.sciclone.clusters.ClonEvol.output/test.sciclone.clusters.model.pdf  && if [ -a test.sciclone.clusters.ClonEvol.output/model.trimmed-trees.pdf]; then mv test.sciclone.clusters.ClonEvol.output/model.trimmed-trees.pdf test.sciclone.clusters.ClonEvol.output/test.sciclone.clusters.model.trimmed-trees.pdf; fi",
        "sbg:createdOn": 1468512646,
        "stdin": "",
        "sbg:toolAuthor": "Ha X. Dang, Brian S. White, Steven M. Foltz, Christopher A. Miller, Jingqin Luo, Ryan C. Fields, Christopher A. Maher",
        "sbg:createdBy": "uros_sipetic",
        "temporaryFailCodes": [],
        "id": "uros_sipetic/clonevol-0-1/clonevol-0-1/59",
        "sbg:latestRevision": 59,
        "sbg:project": "uros_sipetic/clonevol-0-1",
        "outputs": [
          {
            "outputBinding": {
              "sbg:inheritMetadataFrom": "#input_file",
              "glob": "{*.ClonEvol.output/*,*.pdf}"
            },
            "description": "All plots outputed by ClonEvol tool.",
            "id": "#clonevol_plots",
            "sbg:fileTypes": "PDF,PNG",
            "type": [
              "null",
              {
                "items": "File",
                "type": "array",
                "name": "clonevol_plots"
              }
            ],
            "label": "ClonEvol plot files"
          },
          {
            "outputBinding": {
              "sbg:inheritMetadataFrom": "#input_file",
              "glob": "*clonevol_model.RData"
            },
            "description": "File containing a ClonEvol model as an R object that can further be used for getting adequate plots with the Fishplot tool.",
            "id": "#clonevol_model",
            "sbg:fileTypes": "RData",
            "type": [
              "null",
              "File"
            ],
            "label": "ClonEvol model"
          }
        ],
        "arguments": [
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  if ($job.inputs.known_cancer_genes && $job.inputs.gtf) {\n    return \"&& Rscript ClonEvol.R\"\n  } else {\n    return \"Rscript ClonEvol.R\"\n  }\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            },
            "position": 99
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  var x = $job.inputs.input_clusters_file\n  var y = x.path.split('/').pop()\n  var z = y + \".ClonEvol.output\"\n  return \"&& mv \" + z + \"/model.pdf \" + z + \"/\" + y + \".model.pdf\"\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            },
            "position": 100
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  var x = $job.inputs.input_clusters_file\n  var y = x.path.split('/').pop()\n  var z = y + \".ClonEvol.output\"\n  var COMMAND = \"&& if [ -a \" + z + \"/model.trimmed-trees.pdf]; \"\n  COMMAND += \"then mv \" + z + \"/model.trimmed-trees.pdf \" + z + \"/\" + y + \".model.trimmed-trees.pdf; \"\n  COMMAND += \"fi\"\n  return COMMAND\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            },
            "position": 101
          }
        ],
        "sbg:revisionsInfo": [
          {
            "sbg:revisionNotes": null,
            "sbg:modifiedBy": "uros_sipetic",
            "sbg:modifiedOn": 1468512646,
            "sbg:revision": 0
          },
          {
            "sbg:revisionNotes": null,
            "sbg:modifiedBy": "uros_sipetic",
            "sbg:modifiedOn": 1468513154,
            "sbg:revision": 1
          },
          {
            "sbg:revisionNotes": null,
            "sbg:modifiedBy": "uros_sipetic",
            "sbg:modifiedOn": 1468576757,
            "sbg:revision": 2
          },
          {
            "sbg:revisionNotes": null,
            "sbg:modifiedBy": "uros_sipetic",
            "sbg:modifiedOn": 1468590965,
            "sbg:revision": 3
          },
          {
            "sbg:revisionNotes": null,
            "sbg:modifiedBy": "uros_sipetic",
            "sbg:modifiedOn": 1468591378,
            "sbg:revision": 4
          },
          {
            "sbg:revisionNotes": null,
            "sbg:modifiedBy": "uros_sipetic",
            "sbg:modifiedOn": 1468930349,
            "sbg:revision": 5
          },
          {
            "sbg:revisionNotes": null,
            "sbg:modifiedBy": "uros_sipetic",
            "sbg:modifiedOn": 1468932199,
            "sbg:revision": 6
          },
          {
            "sbg:revisionNotes": null,
            "sbg:modifiedBy": "uros_sipetic",
            "sbg:modifiedOn": 1468939798,
            "sbg:revision": 7
          },
          {
            "sbg:revisionNotes": null,
            "sbg:modifiedBy": "uros_sipetic",
            "sbg:modifiedOn": 1468946425,
            "sbg:revision": 8
          },
          {
            "sbg:revisionNotes": null,
            "sbg:modifiedBy": "uros_sipetic",
            "sbg:modifiedOn": 1468949211,
            "sbg:revision": 9
          },
          {
            "sbg:revisionNotes": null,
            "sbg:modifiedBy": "uros_sipetic",
            "sbg:modifiedOn": 1469008442,
            "sbg:revision": 10
          },
          {
            "sbg:revisionNotes": null,
            "sbg:modifiedBy": "uros_sipetic",
            "sbg:modifiedOn": 1469015549,
            "sbg:revision": 11
          },
          {
            "sbg:revisionNotes": null,
            "sbg:modifiedBy": "uros_sipetic",
            "sbg:modifiedOn": 1471266088,
            "sbg:revision": 12
          },
          {
            "sbg:revisionNotes": null,
            "sbg:modifiedBy": "uros_sipetic",
            "sbg:modifiedOn": 1471266285,
            "sbg:revision": 13
          },
          {
            "sbg:revisionNotes": "Added the recommended fix when only one sample is provided.",
            "sbg:modifiedBy": "uros_sipetic",
            "sbg:modifiedOn": 1471268455,
            "sbg:revision": 14
          },
          {
            "sbg:revisionNotes": null,
            "sbg:modifiedBy": "uros_sipetic",
            "sbg:modifiedOn": 1471268571,
            "sbg:revision": 15
          },
          {
            "sbg:revisionNotes": null,
            "sbg:modifiedBy": "uros_sipetic",
            "sbg:modifiedOn": 1471268604,
            "sbg:revision": 16
          },
          {
            "sbg:revisionNotes": null,
            "sbg:modifiedBy": "uros_sipetic",
            "sbg:modifiedOn": 1471268826,
            "sbg:revision": 17
          },
          {
            "sbg:revisionNotes": null,
            "sbg:modifiedBy": "uros_sipetic",
            "sbg:modifiedOn": 1471269942,
            "sbg:revision": 18
          },
          {
            "sbg:revisionNotes": null,
            "sbg:modifiedBy": "uros_sipetic",
            "sbg:modifiedOn": 1471270568,
            "sbg:revision": 19
          },
          {
            "sbg:revisionNotes": null,
            "sbg:modifiedBy": "uros_sipetic",
            "sbg:modifiedOn": 1471272253,
            "sbg:revision": 20
          },
          {
            "sbg:revisionNotes": null,
            "sbg:modifiedBy": "uros_sipetic",
            "sbg:modifiedOn": 1471275048,
            "sbg:revision": 21
          },
          {
            "sbg:revisionNotes": null,
            "sbg:modifiedBy": "uros_sipetic",
            "sbg:modifiedOn": 1471276068,
            "sbg:revision": 22
          },
          {
            "sbg:revisionNotes": null,
            "sbg:modifiedBy": "uros_sipetic",
            "sbg:modifiedOn": 1471277068,
            "sbg:revision": 23
          },
          {
            "sbg:revisionNotes": null,
            "sbg:modifiedBy": "uros_sipetic",
            "sbg:modifiedOn": 1471351030,
            "sbg:revision": 24
          },
          {
            "sbg:revisionNotes": null,
            "sbg:modifiedBy": "uros_sipetic",
            "sbg:modifiedOn": 1471361518,
            "sbg:revision": 25
          },
          {
            "sbg:revisionNotes": null,
            "sbg:modifiedBy": "uros_sipetic",
            "sbg:modifiedOn": 1471361994,
            "sbg:revision": 26
          },
          {
            "sbg:revisionNotes": null,
            "sbg:modifiedBy": "uros_sipetic",
            "sbg:modifiedOn": 1471362553,
            "sbg:revision": 27
          },
          {
            "sbg:revisionNotes": null,
            "sbg:modifiedBy": "uros_sipetic",
            "sbg:modifiedOn": 1471362846,
            "sbg:revision": 28
          },
          {
            "sbg:revisionNotes": null,
            "sbg:modifiedBy": "uros_sipetic",
            "sbg:modifiedOn": 1471363214,
            "sbg:revision": 29
          },
          {
            "sbg:revisionNotes": null,
            "sbg:modifiedBy": "uros_sipetic",
            "sbg:modifiedOn": 1471366284,
            "sbg:revision": 30
          },
          {
            "sbg:revisionNotes": null,
            "sbg:modifiedBy": "uros_sipetic",
            "sbg:modifiedOn": 1471366334,
            "sbg:revision": 31
          },
          {
            "sbg:revisionNotes": null,
            "sbg:modifiedBy": "uros_sipetic",
            "sbg:modifiedOn": 1471366686,
            "sbg:revision": 32
          },
          {
            "sbg:revisionNotes": null,
            "sbg:modifiedBy": "uros_sipetic",
            "sbg:modifiedOn": 1471367282,
            "sbg:revision": 33
          },
          {
            "sbg:revisionNotes": null,
            "sbg:modifiedBy": "uros_sipetic",
            "sbg:modifiedOn": 1471368170,
            "sbg:revision": 34
          },
          {
            "sbg:revisionNotes": null,
            "sbg:modifiedBy": "uros_sipetic",
            "sbg:modifiedOn": 1472562374,
            "sbg:revision": 35
          },
          {
            "sbg:revisionNotes": null,
            "sbg:modifiedBy": "uros_sipetic",
            "sbg:modifiedOn": 1472562831,
            "sbg:revision": 36
          },
          {
            "sbg:revisionNotes": null,
            "sbg:modifiedBy": "uros_sipetic",
            "sbg:modifiedOn": 1472562896,
            "sbg:revision": 37
          },
          {
            "sbg:revisionNotes": null,
            "sbg:modifiedBy": "uros_sipetic",
            "sbg:modifiedOn": 1472568087,
            "sbg:revision": 38
          },
          {
            "sbg:revisionNotes": null,
            "sbg:modifiedBy": "uros_sipetic",
            "sbg:modifiedOn": 1472568175,
            "sbg:revision": 39
          },
          {
            "sbg:revisionNotes": null,
            "sbg:modifiedBy": "uros_sipetic",
            "sbg:modifiedOn": 1472634413,
            "sbg:revision": 40
          },
          {
            "sbg:revisionNotes": null,
            "sbg:modifiedBy": "uros_sipetic",
            "sbg:modifiedOn": 1472637716,
            "sbg:revision": 41
          },
          {
            "sbg:revisionNotes": null,
            "sbg:modifiedBy": "uros_sipetic",
            "sbg:modifiedOn": 1472647534,
            "sbg:revision": 42
          },
          {
            "sbg:revisionNotes": null,
            "sbg:modifiedBy": "uros_sipetic",
            "sbg:modifiedOn": 1473505933,
            "sbg:revision": 43
          },
          {
            "sbg:revisionNotes": null,
            "sbg:modifiedBy": "uros_sipetic",
            "sbg:modifiedOn": 1473932253,
            "sbg:revision": 44
          },
          {
            "sbg:revisionNotes": null,
            "sbg:modifiedBy": "uros_sipetic",
            "sbg:modifiedOn": 1473945323,
            "sbg:revision": 45
          },
          {
            "sbg:revisionNotes": null,
            "sbg:modifiedBy": "uros_sipetic",
            "sbg:modifiedOn": 1476875143,
            "sbg:revision": 46
          },
          {
            "sbg:revisionNotes": null,
            "sbg:modifiedBy": "uros_sipetic",
            "sbg:modifiedOn": 1476877000,
            "sbg:revision": 47
          },
          {
            "sbg:revisionNotes": null,
            "sbg:modifiedBy": "uros_sipetic",
            "sbg:modifiedOn": 1476877049,
            "sbg:revision": 48
          },
          {
            "sbg:revisionNotes": null,
            "sbg:modifiedBy": "uros_sipetic",
            "sbg:modifiedOn": 1476877617,
            "sbg:revision": 49
          },
          {
            "sbg:revisionNotes": null,
            "sbg:modifiedBy": "uros_sipetic",
            "sbg:modifiedOn": 1476877761,
            "sbg:revision": 50
          },
          {
            "sbg:revisionNotes": null,
            "sbg:modifiedBy": "uros_sipetic",
            "sbg:modifiedOn": 1476878808,
            "sbg:revision": 51
          },
          {
            "sbg:revisionNotes": null,
            "sbg:modifiedBy": "uros_sipetic",
            "sbg:modifiedOn": 1476879445,
            "sbg:revision": 52
          },
          {
            "sbg:revisionNotes": null,
            "sbg:modifiedBy": "uros_sipetic",
            "sbg:modifiedOn": 1476881063,
            "sbg:revision": 53
          },
          {
            "sbg:revisionNotes": null,
            "sbg:modifiedBy": "uros_sipetic",
            "sbg:modifiedOn": 1476957786,
            "sbg:revision": 54
          },
          {
            "sbg:revisionNotes": null,
            "sbg:modifiedBy": "uros_sipetic",
            "sbg:modifiedOn": 1477497724,
            "sbg:revision": 55
          },
          {
            "sbg:revisionNotes": null,
            "sbg:modifiedBy": "uros_sipetic",
            "sbg:modifiedOn": 1477500623,
            "sbg:revision": 56
          },
          {
            "sbg:revisionNotes": null,
            "sbg:modifiedBy": "uros_sipetic",
            "sbg:modifiedOn": 1477503239,
            "sbg:revision": 57
          },
          {
            "sbg:revisionNotes": null,
            "sbg:modifiedBy": "uros_sipetic",
            "sbg:modifiedOn": 1477996760,
            "sbg:revision": 58
          },
          {
            "sbg:revisionNotes": null,
            "sbg:modifiedBy": "uros_sipetic",
            "sbg:modifiedOn": 1480076302,
            "sbg:revision": 59
          }
        ],
        "sbg:categories": [
          "Tumor-heterogeneity",
          "Sub-clonality",
          "Cancer"
        ],
        "hints": [
          {
            "class": "sbg:CPURequirement",
            "value": 1
          },
          {
            "class": "sbg:MemRequirement",
            "value": 1000
          },
          {
            "class": "DockerRequirement",
            "dockerPull": "images.sbgenomics.com/uros_sipetic/clonevol:0.1",
            "dockerImageId": ""
          }
        ],
        "sbg:contributors": [
          "uros_sipetic"
        ],
        "label": "ClonEvol 0.1",
        "sbg:license": "GNU General Public License v3.0 only",
        "sbg:validationErrors": [],
        "sbg:links": [
          {
            "id": "https://github.com/hdng/clonevol",
            "label": "Homepage"
          },
          {
            "id": "https://github.com/hdng/clonevol",
            "label": "Source Code"
          },
          {
            "id": "https://github.com/hdng/clonevol/archive/v0.1.tar.gz",
            "label": "Download"
          },
          {
            "id": "ClonEvol: inferring and visualizing clonal evolution in multi-sample cancer sequencing (under review)",
            "label": "Publication"
          },
          {
            "id": "https://github.com/hdng/clonevol/tree/master/man",
            "label": "Documentation"
          }
        ],
        "sbg:job": {
          "allocatedResources": {
            "mem": 1000,
            "cpu": 1
          },
          "inputs": {
            "subclonal_test_method": null,
            "scale_monoclonal_cell_frac": true,
            "known_cancer_genes": {
              "path": "d",
              "size": 0,
              "secondaryFiles": [],
              "class": "File"
            },
            "input_clusters_file": {
              "path": "/path/to/test.sciclone.clusters",
              "size": 0,
              "secondaryFiles": [],
              "class": "File"
            },
            "gtf": {
              "path": "d",
              "size": 0,
              "secondaryFiles": [],
              "class": "File"
            },
            "out_format": null,
            "model": "monoclonal"
          }
        },
        "description": "ClonEvol is used for inferring and visualizing clonal evolution in multi-sample cancer sequencing. \n\nClonEvol infers clonal evolution models in single sample or multiple samples using the clusters of variants identified previously using other methods such as sciClone or PyClone. Variant clusters must be biologically interpretable for ClonEvol to be able to infer some models. Most of the time you will find yourself iteratively refining the clustering of the variants and running ClonEvol, until some reasonable models are found.\n\nClonEvol can infer clonal structures end evolution models for multi cancer samles from a single patient (eg primary tumors, metastatic tumors, xenograft tumors, multi-region samples, etc.).\n\n### Common Issues ###\nCurrently, ClonEvol works well using SciClone results as input files.",
        "stdout": "",
        "sbg:toolkit": "ClonEvol",
        "sbg:toolkitVersion": "0.1",
        "sbg:revision": 59,
        "sbg:id": "uros_sipetic/clonevol-0-1/clonevol-0-1/59",
        "sbg:modifiedOn": 1480076302,
        "requirements": [
          {
            "class": "CreateFileRequirement",
            "fileDef": [
              {
                "filename": "ClonEvol.R",
                "fileContent": {
                  "script": "{\n  var COMMAND = \"library(clonevol)\\n\"\n  z = \"library(ggplot2)\\n\"\n  z += \"options(expressions=10000)\\n\"\n  COMMAND += z\n  \n  var TAG = false\n  if ($job.inputs.known_cancer_genes && $job.inputs.gtf) {\n    var TAG = true\n  }\n  \n  //load data\n  if (TAG) {\n    y = 'sciclone_clusters_parsed'\n  } else {\n    x = $job.inputs.input_clusters_file\n    y = x.path.split('/').pop()\n  }\n  z = \"data = read.table('\" + y + \"',header=T)\\n\"\n  z += \"data = data[!is.na(data$cluster),]\\n\"\n  z += \"vaf.col.names <- grep('.vaf', colnames(data), value=TRUE, fixed=TRUE)\\n\"\n  COMMAND += z\n  \n  //infer clonal evolution models\n  z = \"x <- infer.clonal.models(variants=data,\\n\\\n\t\t   cluster.col.name='cluster',\\n\\\n\t\t   vaf.col.names=vaf.col.names,\\n\\\n\t\t   subclonal.test.model='non-parametric',\\n\\\n\t\t   cluster.center='mean',\\n\\\n\t\t   num.boots=1000,\\n\\\n\t\t   founding.cluster=1,\\n\\\n\t\t   min.cluster.vaf=0.01,\\n\\\n\t\t   p.value.cutoff=0.01,\\n\\\n\t\t   alpha=0.1,\\n\\\n\t\t   random.seed=63108\"\n  if ($job.inputs.subclonal_test_method) {\n    x = $job.inputs.subclonal_test_method\n    z += \",\\n\\\n\t\t   subclonal.test='\" + x + \"'\"\n  } else {\n    z += \",\\n\\\n\t\t   subclonal.test='bootstrap'\"\n  }\n  if ($job.inputs.model) {\n    x = $job.inputs.model\n    z += \",\\n\\\n\t\t   model='\" + x + \"')\\n\"\n  } else {\n    z += \")\\n\"\n  }\n  COMMAND += z\n  \n  //plot clonal evolution models\n  x = $job.inputs.input_clusters_file\n  y = x.path.split('/').pop()\n  z = \"plot.clonal.models(x$models,\\n\\\n\t\t   matched=x$matched,\\n\\\n\t\t   variants=data,\\n\\\n\t\t   clone.shape='bell',\\n\\\n\t\t   box.plot=TRUE,\\n\\\n\t\t   overwrite.output=TRUE,\\n\\\n\t\t   cell.frac.ci=TRUE,\\n\\\n\t\t   tree.node.shape='circle',\\n\\\n\t\t   tree.node.size=40,\\n\\\n\t\t   tree.node.text.size=0.65,\\n\\\n\t\t   out.dir='\" + y + \".ClonEvol.output'\"\n  if ($job.inputs.scale_monoclonal_cell_frac) {\n    x = $job.inputs.scale_monoclonal_cell_frac\n    z += \",\\n\\\n\t\t   scale.monoclonal.cell.frac=\" + String(x).toUpperCase()\n  }\n  if ($job.inputs.out_format) {\n    x = $job.inputs.out_format\n    z += \",\\n\\\n\t\t   out.format='\" + x + \"')\\n\"\n  } else {\n    z += \",\\n\\\n\t\t   out.format='pdf')\\n\"\n  }\n  COMMAND += z\n  \n  if (TAG) {\n  //plot clonal evolution models (with variant highlight in bell plots)\n  x = $job.inputs.input_clusters_file\n  y = x.path.split('/').pop()\n  z = \"var.to.highlight = data[data$is.cancer.gene, c('cluster', 'gene')]\\n\"\n  z += \"colnames(var.to.highlight) = c('cluster', 'variant.name')\\n\"\n  COMMAND += z\n  z = \"plot.clonal.models(x$models,\\n\\\n\t\t   matched=x$matched,\\n\\\n\t\t   variants=data,\\n\\\n\t\t   clone.shape='bell',\\n\\\n\t\t   box.plot=TRUE,\\n\\\n\t\t   overwrite.output=TRUE,\\n\\\n\t\t   cell.frac.ci=TRUE,\\n\\\n\t\t   variants.to.highlight=var.to.highlight,\\n\\\n \t\t   variant.color='blue',\\n\\\n \t\t   variant.angle=60,\\n\\\n\t\t   tree.node.shape='circle',\\n\\\n\t\t   tree.node.size=40,\\n\\\n\t\t   tree.node.text.size=0.65,\\n\\\n\t\t   out.dir='\" + y + \".bell.ClonEval.output'\"\n  if ($job.inputs.scale_monoclonal_cell_frac) {\n    x = $job.inputs.scale_monoclonal_cell_frac\n    z += \",\\n\\\n\t\t   scale.monoclonal.cell.frac=\" + String(x).toUpperCase()\n  }\n  if ($job.inputs.out_format) {\n    x = $job.inputs.out_format\n    z += \",\\n\\\n\t\t   out.format='\" + x + \"')\\n\"\n  } else {\n    z += \")\\n\"\n  }\n  COMMAND += z\n\n  //plot box/violin/jitter of VAFs with cancer gene variants highlighted\n  x = $job.inputs.input_clusters_file\n  y = x.path.split('/').pop()\n  z = \"num.clusters <- length(unique(data$cluster))\\n\"\n  z += \"pdf('\" + y + \".variants.jitter.pdf', width=5, height=5, useDingbats=FALSE)\\n\"\n  COMMAND += z\n  \n  z = \"pp = variant.box.plot(data,\\n\\\n\t\t   vaf.col.names=vaf.col.names,\\n\\\n\t\t   variant.class.col.name=NULL,\\n\\\n\t\t   cluster.axis.name='',\\n\\\n\t\t   vaf.limits=70,\\n\\\n\t\t   violin=FALSE,\\n\\\n\t\t   box=FALSE,\\n\\\n\t\t   order.by.total.vaf=FALSE,\\n\\\n\t\t   jitter=TRUE,\\n\\\n\t\t   jitter.center.method='mean',\\n\\\n\t\t   jitter.center.size=0.5,\\n\\\n\t\t   jitter.center.color='darkgray',\\n\\\n\t\t   jitter.shape=1,\\n\\\n\t\t   jitter.color=get.clonevol.colors(num.clusters),\\n\\\n\t\t   jitter.size=2,\\n\\\n\t\t   jitter.alpha=1,\\n\\\n\t\t   highlight='is.cancer.gene',\\n\\\n\t\t   highlight.note.col.name='gene',\\n\\\n\t\t   highlight.shape=19,\\n\\\n\t\t   display.plot=TRUE)\\n\"\n  z += \"dev.off()\\n\"\n  COMMAND += z\n  }\n  \n  //plot pairwise VAFs across samples\n  x = $job.inputs.input_clusters_file\n  y = x.path.split('/').pop()\n  z = \"num.clusters <- length(unique(data$cluster))\\n\"\n  if (TAG) {\n    z += \"if (ncol(data)>18) {\\n\" \n  } else {\n    z += \"if (ncol(data)>16) {\\n\" \n  }\n  z += \"plot.pairwise(data, col.names=vaf.col.names,\\n\\\n\t\t   out.prefix='\" + y + \".variants.pairwise.plot',\\n\\\n\t\t   colors=get.clonevol.colors(num.clusters))\\n}\\n\"\n  COMMAND += z\n  \n  //plot mean/median of clusters across samples (cluster flow)\n  z = \"s1 = gsub('.{4}$', '', vaf.col.names)\\n\"\n  COMMAND += z\n  z = \"plot.cluster.flow(data, vaf.col.names=vaf.col.names,\\n\\\n\t\t   out.file='\" + y + \".flow.pdf',\\n\\\n\t\t   colors=get.clonevol.colors(num.clusters),\\n\\\n\t\t   sample.names=s1)\\n\"\n  COMMAND += z\n  \n  //if only one sample - copy the sample to make fishplot work\n  if (TAG) {\n    z = \"if (ncol(data)<19) {\\n\" \n  } else {\n    z = \"if (ncol(data)<17) {\\n\" \n  }\n  z += \"data[,paste0(vaf.col.names,'2')] = data[,vaf.col.names]\\n\\\nvaf.col.names = c(vaf.col.names, paste0(vaf.col.names,'2'))\\n\\\ns1 = gsub('.{4}$', '', vaf.col.names)\\n\"\n  z += \"x <- infer.clonal.models(variants=data,\\n\\\n\t\t   cluster.col.name='cluster',\\n\\\n\t\t   vaf.col.names=vaf.col.names,\\n\\\n\t\t   subclonal.test.model='non-parametric',\\n\\\n\t\t   cluster.center='mean',\\n\\\n\t\t   num.boots=1000,\\n\\\n\t\t   founding.cluster=1,\\n\\\n\t\t   min.cluster.vaf=0.01,\\n\\\n\t\t   p.value.cutoff=0.01,\\n\\\n\t\t   alpha=0.1,\\n\\\n\t\t   random.seed=63108\"\n  if ($job.inputs.subclonal_test_method) {\n    x = $job.inputs.subclonal_test_method\n    z += \",\\n\\\n\t\t   subclonal.test='\" + x + \"'\"\n  } else {\n    z += \",\\n\\\n\t\t   subclonal.test='bootstrap'\"\n  }\n  if ($job.inputs.model) {\n    x = $job.inputs.model\n    z += \",\\n\\\n\t\t   model='\" + x + \"')\\n\"\n  } else {\n    z += \")\\n\"\n  }\n  z += \"}\\n\"\n\n  COMMAND += z\n  \n  //save variables x and s1 as R object for further use (Fishplot)\n  z = \"save(x, s1, file='\" + y + \".clonevol_model.RData')\\n\"\n  COMMAND += z\n  \n  //return whole script\n  return COMMAND\n}\n  \n  ",
                  "class": "Expression",
                  "engine": "#cwl-js-engine"
                }
              },
              {
                "filename": "add_known_cancer_genes.py",
                "fileContent": "import argparse\n\nparser = argparse.ArgumentParser(description='This script adds a \"gene\" and \"is.cancer.gene\" columns to the SciClone \"clusters\" output file.')\nparser.add_argument('-s','--sciclone', help='Input SciClone \"clusters\" file.', required=True)\nparser.add_argument('-g','--gtf', help='Input GTF file.', required=True)\nparser.add_argument('-c','--cancer_genes', help='Databse of known cancer genes, like COSMIC.', required=True)\nargs = vars(parser.parse_args())\n\nsciclone_file = args['sciclone']\ngtf_file = args['gtf']\ncancer_genes_file = args['cancer_genes']\n\nwith open(gtf_file, 'r') as gtf_content_file:\n    gtf_content = gtf_content_file.read()\nwith open(cancer_genes_file, 'r') as cancer_content_file:\n    cancer_content = cancer_content_file.read()\nwith open(sciclone_file, 'r') as sciclone_content_file:\n    sciclone_content = sciclone_content_file.read()\n\n\ngtf_lines = gtf_content.split('\\n')\ngtf_lines.pop()\ngtf_fields = [];\nfor tmp_fields in gtf_lines:\n    if tmp_fields[0]=='#':\n        continue\n    tmp_splited = tmp_fields.split('\\t')\n    if tmp_splited[2]=='gene':\n        tmp_list = [];\n        tmp_list.append(tmp_splited[0])\n        tmp_list.append(tmp_splited[3])\n        tmp_list.append(tmp_splited[4])\n        details_splited = tmp_splited[-1].split(';')\n        for tmp_details in details_splited:\n            if tmp_details[1:10] == 'gene_name':\n                tmp_list.append(tmp_details[12:-1])\n                break\n        gtf_fields.append(tmp_list)\n    \ncancer_lines = cancer_content.split('\\n')\ncancer_lines.pop()\ncancer_fields = [];\nfor tmp_fields in cancer_lines:\n    if tmp_fields[0]=='#':\n        continue\n    tmp_splited = tmp_fields.split('\\t')\n    \n    tmp_list = [];\n    tmp_list.append(tmp_splited[0])\n    tmp_list.append(tmp_splited[1])\n    cancer_fields.append(tmp_list)\n\n\nsciclone_lines = sciclone_content.split('\\n')\nsciclone_lines.pop()\n\np = ''\nfor line in sciclone_lines:\n    if line[0:4]=='chr\\t':\n        p += line + '\\t' + 'gene' + '\\t' + 'is.cancer.gene' + '\\n'\n        continue\n    x = line.split('\\t')\n    if line[0:3]=='chr':\n        chr_number = x[0][3:len(x)+1]\n    else:\n        chr_number = x[0]\n    \n    position = int(x[1])\n    \n    found_gene = False\n    for gtf_line in gtf_fields:\n        if gtf_line[0][0:3]=='chr':\n            gtf_chr_number = gtf_line[0][3:len(gtf_line)+1]\n        else:\n            gtf_chr_number = gtf_line[0]\n                \n        if ((chr_number == gtf_chr_number) and (int(gtf_line[1]) <= position) and (int(gtf_line[2]) >= position)):\n            found_gene = True            \n            ind = False            \n            for cancer_line in cancer_fields:\n                if cancer_line[0:3]=='chr':\n                    cancer_chr_number = cancer_line[0][3:len(cancer_line)+1]\n                else:\n                    cancer_chr_number = cancer_line[0]   \n                if(cancer_chr_number == chr_number) and (int(gtf_line[1]) <= int(cancer_line[1])) and (int(gtf_line[2]) >= int(cancer_line[1])):\n                    ind = True\n                if ind:\n                    p+= line + '\\t' + gtf_line[-1] + '\\t' + 'TRUE\\n'\n                    break\n                \n            if ind==False:                    \n                p+= line + '\\t' + gtf_line[-1] + '\\t' + 'FALSE\\n'\n                \n            break\n    if found_gene == False:\n        p+= line + '\\t' + 'NA' + '\\t' + 'FALSE\\n'\n    \nwith open('sciclone_clusters_parsed', \"w\") as f:\n    f.write(p)"
              }
            ]
          },
          {
            "requirements": [
              {
                "class": "DockerRequirement",
                "dockerPull": "rabix/js-engine"
              }
            ],
            "id": "#cwl-js-engine",
            "class": "ExpressionEngineRequirement"
          }
        ],
        "class": "CommandLineTool",
        "sbg:sbgMaintained": false,
        "x": 1595.94775390625,
        "y": 323.22821044921875,
        "cwlVersion": "sbg:draft-2",
        "sbg:image_url": null,
        "inputs": [
          {
            "sbg:category": "Arguments",
            "sbg:toolDefaultValue": "bootstrap",
            "description": "Subclonal test method. 'Bootstrap' perfroms bootstrap subclonal test. 'None' perfroms straight comparison of already estimated VAF for each cluster provided in 'c'.",
            "id": "#subclonal_test_method",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "subclonal_test_method",
                "symbols": [
                  "bootstrap",
                  "none"
                ]
              }
            ],
            "label": "Subclonal test method"
          },
          {
            "sbg:stageInput": null,
            "sbg:category": "Arguments",
            "sbg:toolDefaultValue": "TRUE",
            "description": "Scale cellular fraction in the plots (ie. cell fraction will be scaled by 1/purity = 1/max(VAF*2)).",
            "id": "#scale_monoclonal_cell_frac",
            "type": [
              "null",
              "boolean"
            ],
            "label": "Scale cellular fraction"
          },
          {
            "sbg:category": "Arguments",
            "sbg:toolDefaultValue": "pdf",
            "description": "Format of the plot files.",
            "id": "#out_format",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "out_format",
                "symbols": [
                  "png",
                  "pdf",
                  "pdf.multi.files"
                ]
              }
            ],
            "label": "Output format"
          },
          {
            "sbg:stageInput": null,
            "sbg:category": "Arguments",
            "sbg:toolDefaultValue": "monoclonal",
            "description": "Cancer evolution model to use. Monoclonal model assumes the original tumor (eg. primary tumor) arises from a single normal cell; polyclonal model assumes the original tumor can arise from multiple cells (ie. multiple founding clones). In the polyclonal model, the total VAF of the separate founding clones must not exceed 0.5.",
            "id": "#model",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "model",
                "symbols": [
                  "monoclonal",
                  "polyclonal"
                ]
              }
            ],
            "label": "Cancer evolution model"
          },
          {
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "valueFrom": {
                "script": "{\n  if ($job.inputs.known_cancer_genes && $job.inputs.gtf) {\n    return \"-c \" + $job.inputs.known_cancer_genes.path\n  }\n}",
                "class": "Expression",
                "engine": "#cwl-js-engine"
              }
            },
            "sbg:category": "Inputs",
            "description": "Databse of known cancer genes, like COSMIC. This file is optional, and you can supply it if you want to plot clonal evolution models with variant highlight in bell plots.",
            "required": false,
            "id": "#known_cancer_genes",
            "sbg:altPrefix": "--cancer_genes",
            "sbg:fileTypes": "VCF,TXT",
            "type": [
              "null",
              "File"
            ],
            "label": "Known cancer genes database"
          },
          {
            "sbg:stageInput": "link",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "valueFrom": {
                "script": "{\n  if ($job.inputs.known_cancer_genes && $job.inputs.gtf) {\n    return \"-s \" + $job.inputs.input_clusters_file.path\n  }\n}",
                "class": "Expression",
                "engine": "#cwl-js-engine"
              }
            },
            "sbg:category": "Inputs",
            "sbg:toolDefaultValue": "NULL",
            "description": "Clonality analysis data frame, consisting of a 'clusters' column and columns containing VAF data for all samples that need to be analyzed. Currently ClonEvol works best if this file came from SciClone or PyClone tools.",
            "required": true,
            "id": "#input_clusters_file",
            "sbg:altPrefix": "--sciclone",
            "sbg:fileTypes": "TXT,CLUSTERS",
            "type": [
              "File"
            ],
            "label": "Clonality analysis data frame"
          },
          {
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "valueFrom": {
                "script": "{\n  if ($job.inputs.known_cancer_genes && $job.inputs.gtf) {\n    return \"-g \" + $job.inputs.gtf.path\n  }\n}",
                "class": "Expression",
                "engine": "#cwl-js-engine"
              }
            },
            "sbg:category": "Inputs",
            "description": "A GTF file containing gene annonations. This file is optional, and you can supply it if you want to plot clonal evolution models with variant highlight in bell plots.",
            "required": false,
            "id": "#gtf",
            "sbg:altPrefix": "--gtf",
            "sbg:fileTypes": "GTF",
            "type": [
              "null",
              "File"
            ],
            "label": "Gene annotation file"
          }
        ],
        "sbg:modifiedBy": "uros_sipetic",
        "successCodes": [],
        "baseCommand": [
          {
            "script": "{\n  if ($job.inputs.known_cancer_genes && $job.inputs.gtf) {\n    return \"python add_known_cancer_genes.py\"\n  }\n}",
            "class": "Expression",
            "engine": "#cwl-js-engine"
          }
        ]
      },
      "inputs": [
        {
          "id": "#ClonEvol_0_1.subclonal_test_method"
        },
        {
          "id": "#ClonEvol_0_1.scale_monoclonal_cell_frac"
        },
        {
          "id": "#ClonEvol_0_1.out_format"
        },
        {
          "id": "#ClonEvol_0_1.model"
        },
        {
          "id": "#ClonEvol_0_1.known_cancer_genes",
          "source": [
            "#known_cancer_genes"
          ]
        },
        {
          "id": "#ClonEvol_0_1.input_clusters_file",
          "source": [
            "#SciClone_1_1.clusters"
          ]
        },
        {
          "id": "#ClonEvol_0_1.gtf",
          "source": [
            "#gtf"
          ]
        }
      ]
    },
    {
      "sbg:x": 275.70585363051475,
      "outputs": [
        {
          "id": "#SBG_VCF_reheader.reheaded_vcf"
        }
      ],
      "id": "#SBG_VCF_reheader",
      "sbg:y": 309.6695305319394,
      "scatter": "#SBG_VCF_reheader.vcf",
      "run": {
        "sbg:cmdPreview": "python vcf_parser.py -v /path/to/merged.vcf -s merged -o merged.reheaded.vcf",
        "sbg:createdOn": 1477582499,
        "stdin": "",
        "sbg:toolAuthor": "Seven Bridges Genomics",
        "sbg:createdBy": "uros_sipetic",
        "temporaryFailCodes": [],
        "id": "bix-demo/sbgtools-demo/sbg-vcf-reheader/2",
        "sbg:latestRevision": 2,
        "sbg:project": "bix-demo/sbgtools-demo",
        "outputs": [
          {
            "outputBinding": {
              "sbg:inheritMetadataFrom": "#vcf",
              "glob": "*.reheaded.vcf"
            },
            "description": "A VCF with changed last sample name column into the appropriate sample name.",
            "id": "#reheaded_vcf",
            "sbg:fileTypes": "VCF",
            "type": [
              "null",
              "File"
            ],
            "label": "Reheaded VCF"
          }
        ],
        "arguments": [
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  var tmp1 = [].concat($job.inputs.vcf)[0].path.split('/').pop()\n  var str1 = tmp1.split('.')\n  var x1 = \"\"\n  for (i=0; i<str1.length-1; i++) {\n    if (i<str1.length-2) { \n    x1 = x1 + str1[i] + \".\"\n    }\n    else {\n      x1 = x1 + str1[i]\n    }\n  }\n  return x1 + \".reheaded.vcf\"\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            },
            "prefix": "-o",
            "position": 3
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  if ($job.inputs.vcf.metadata && $job.inputs.vcf.metadata.sample_id) {\n    return $job.inputs.vcf.metadata.sample_id\n  } else {\n    return $job.inputs.vcf.path.split('/').pop().split('.')[0]\n  }\n}\n",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            },
            "prefix": "-s",
            "position": 2
          }
        ],
        "sbg:revisionsInfo": [
          {
            "sbg:revisionNotes": "Copy of uros_sipetic/playground/sbg-vcf-reheader/2",
            "sbg:modifiedBy": "uros_sipetic",
            "sbg:modifiedOn": 1477582499,
            "sbg:revision": 0
          },
          {
            "sbg:revisionNotes": null,
            "sbg:modifiedBy": "uros_sipetic",
            "sbg:modifiedOn": 1479734228,
            "sbg:revision": 1
          },
          {
            "sbg:revisionNotes": "Sample name is derived from the VCF sample_id metadata or file name, instead of a BAM file.",
            "sbg:modifiedBy": "uros_sipetic",
            "sbg:modifiedOn": 1485180158,
            "sbg:revision": 2
          }
        ],
        "sbg:categories": [
          "Other"
        ],
        "hints": [
          {
            "class": "sbg:CPURequirement",
            "value": 1
          },
          {
            "class": "sbg:MemRequirement",
            "value": 1000
          },
          {
            "class": "DockerRequirement",
            "dockerPull": "images.sbgenomics.com/dusan_randjelovic/sci-python:2.7",
            "dockerImageId": ""
          }
        ],
        "sbg:contributors": [
          "uros_sipetic"
        ],
        "label": "SBG VCF reheader",
        "sbg:license": "Apache License 2.0",
        "sbg:validationErrors": [],
        "sbg:job": {
          "allocatedResources": {
            "mem": 1000,
            "cpu": 1
          },
          "inputs": {
            "vcf": {
              "path": "/path/to/merged.vcf",
              "size": 0,
              "secondaryFiles": [],
              "class": "File"
            }
          }
        },
        "appUrl": "/u/bix-demo/sbgtools-demo/apps/#bix-demo/sbgtools-demo/sbg-vcf-reheader/2",
        "description": "This tool changes the last column name in the VCF header to an appropriate sample name. The sample name is acquired from the input VCF sample_id metadata if available, otherwise it is acquired from the VCF file name. \n\n### Common Issues ###\nNone",
        "stdout": "",
        "sbg:toolkit": "SBGTools",
        "sbg:toolkitVersion": "v1.0",
        "sbg:revisionNotes": "Sample name is derived from the VCF sample_id metadata or file name, instead of a BAM file.",
        "sbg:revision": 2,
        "sbg:id": "bix-demo/sbgtools-demo/sbg-vcf-reheader/2",
        "sbg:modifiedOn": 1485180158,
        "requirements": [
          {
            "class": "CreateFileRequirement",
            "fileDef": [
              {
                "filename": "vcf_parser.py",
                "fileContent": "import argparse\n\nparser = argparse.ArgumentParser(description='This tool changes the last column name in the VCF header to an appropriate sample name. The sample name is acquired from the input vcf file sample_id metadata.')\nparser.add_argument('-v','--vcf', help='Input VCF file', required=True)\nparser.add_argument('-s','--sample_id', help='Sample ID', required=True)\nparser.add_argument('-o','--output', help='Output file',required=True)\nargs = vars(parser.parse_args())\n\nvcf_file = args['vcf']\nsampleID = args['sample_id']\noutput_file = args['output']\n\np = \"\"\nwith open(vcf_file) as f:\n    for line in f:\n        if line[0:6]!='#CHROM':\n            p += line \n            continue\n        x = line.split('\\t')\n        tmp2 = x.pop()\n        x.append(sampleID)\n        p += \"\\t\".join(x) + '\\n'\n\n        \nwith open(output_file,\"w\") as f:\n    f.write(p)"
              }
            ]
          },
          {
            "requirements": [
              {
                "class": "DockerRequirement",
                "dockerPull": "rabix/js-engine"
              }
            ],
            "id": "#cwl-js-engine",
            "class": "ExpressionEngineRequirement"
          }
        ],
        "class": "CommandLineTool",
        "sbg:sbgMaintained": false,
        "x": 275.70585363051475,
        "y": 309.6695305319394,
        "cwlVersion": "sbg:draft-2",
        "sbg:image_url": null,
        "inputs": [
          {
            "sbg:stageInput": "link",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "-v",
              "position": 1
            },
            "sbg:category": "Inputs",
            "description": "A VCF file.",
            "required": true,
            "id": "#vcf",
            "sbg:fileTypes": "VCF",
            "type": [
              "File"
            ],
            "label": "VCF file"
          }
        ],
        "sbg:modifiedBy": "uros_sipetic",
        "successCodes": [],
        "baseCommand": [
          "python",
          "vcf_parser.py"
        ]
      },
      "inputs": [
        {
          "id": "#SBG_VCF_reheader.vcf",
          "source": [
            "#VCFtools_Subset.output_file"
          ]
        }
      ]
    },
    {
      "sbg:x": 1162.5001681645758,
      "outputs": [
        {
          "id": "#SciClone_1_1.sciclone_plots"
        },
        {
          "id": "#SciClone_1_1.purity"
        },
        {
          "id": "#SciClone_1_1.clusters"
        },
        {
          "id": "#SciClone_1_1.clusterSummary"
        }
      ],
      "id": "#SciClone_1_1",
      "sbg:y": 310.98485532673897,
      "run": {
        "sbg:cmdPreview": "Rscript --vanilla sciClone.R  && tmp1=$(grep 'cluster1 *' sample1.vafs-1.cluster.summary.means | tr -s $'\\t' | cut -f 2) && tmp2=$(echo \"($tmp1 + $tmp1)*100\" | bc -l) && if (( $(echo \"$tmp2 > 100\" | bc -l) )); then tmp3=\"100\"; else tmp3=$tmp2; fi && echo '[2] Estimated sample tumor purity by looking at cluster centroid data is' $tmp3 >> sample1.vafs-1.estimated_tumor_purity.txt",
        "sbg:createdOn": 1473774679,
        "stdin": "",
        "sbg:toolAuthor": "Christopher A. Miller, Brian S. White, Nathan D. Dees, John S. Welch, Malachi Griffith, Obi Griffith, Ravi Vij, Michael H. Tomasson, Timothy A. Graubert, Matthew J. Walter, William Schierding, Timothy J. Ley, John F. DiPersio, Elaine R. Mardis, Richard K. Wilson, and Li Ding",
        "sbg:createdBy": "uros_sipetic",
        "temporaryFailCodes": [],
        "id": "uros_sipetic/sciclone-1-1-demo/sciclone-1-1/20",
        "sbg:latestRevision": 20,
        "sbg:project": "uros_sipetic/sciclone-1-1-demo",
        "outputs": [
          {
            "outputBinding": {
              "sbg:inheritMetadataFrom": "#vafs",
              "glob": "{*.pdf,*.gif}"
            },
            "description": "Plots containing sub-clonality informations.",
            "id": "#sciclone_plots",
            "sbg:fileTypes": "PDF,GIF",
            "type": [
              "null",
              {
                "items": "File",
                "type": "array"
              }
            ],
            "label": "Plots"
          },
          {
            "outputBinding": {
              "sbg:inheritMetadataFrom": "#vafs",
              "glob": "*purity.txt"
            },
            "description": "Estimated tumor purity for the sample. The estimation is done by analyzing peaks in the kernel density of the main cluster (the one around 50%) and then multiplying that value by two. Note that this is experimental, and due to noisy data, often the result will be defaulted to 100%.",
            "id": "#purity",
            "sbg:fileTypes": "TXT",
            "type": [
              "null",
              "File"
            ],
            "label": "Estimated tumor purity"
          },
          {
            "outputBinding": {
              "sbg:inheritMetadataFrom": "#vafs",
              "glob": "*clusters"
            },
            "description": "File containing clusters information.",
            "id": "#clusters",
            "sbg:fileTypes": "TXT,CLUSTERS",
            "type": [
              "null",
              "File"
            ],
            "label": "Clusters"
          },
          {
            "outputBinding": {
              "sbg:inheritMetadataFrom": "#vafs",
              "glob": "*summary*"
            },
            "description": "Cluster summaries (cluster centers).",
            "id": "#clusterSummary",
            "sbg:fileTypes": "TXT,SUMMARY",
            "type": [
              "null",
              {
                "items": "File",
                "type": "array"
              }
            ],
            "label": "Cluster summaries"
          }
        ],
        "arguments": [
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  x = [].concat($job.inputs.vafs)[0].path.split('/').pop().split('.')\n  y = \"\"\n  for (i=0; i<x.length-1; i++) {\n    if (i<x.length-2) {\n      y += x[i] + \".\"\n    } else {\n      y += x[i]\n    }\n  }\n  var sample_name = y + '.estimated_tumor_purity.txt'\n  return \"&& tmp1=$(grep 'cluster1 *' \" + y + \".cluster.summary.means | tr -s $'\\\\t' | cut -f 2) && tmp2=$(echo \\\"($tmp1 + $tmp1)*100\\\" | bc -l) && if (( $(echo \\\"$tmp2 > 100\\\" | bc -l) )); then tmp3=\\\"100\\\"; else tmp3=$tmp2; fi && echo '[2] Estimated sample tumor purity by looking at cluster centroid data is' $tmp3 >> \" + sample_name\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            },
            "position": 10
          }
        ],
        "sbg:revisionsInfo": [
          {
            "sbg:revisionNotes": "Copy of uros_sipetic/sciclone-1-1/sciclone-1-1/33",
            "sbg:modifiedBy": "uros_sipetic",
            "sbg:modifiedOn": 1473774679,
            "sbg:revision": 0
          },
          {
            "sbg:revisionNotes": "Copy of uros_sipetic/sciclone-1-1/sciclone-1-1/34",
            "sbg:modifiedBy": "uros_sipetic",
            "sbg:modifiedOn": 1473846476,
            "sbg:revision": 1
          },
          {
            "sbg:revisionNotes": "Copy of uros_sipetic/sciclone-1-1/sciclone-1-1/35",
            "sbg:modifiedBy": "uros_sipetic",
            "sbg:modifiedOn": 1473848358,
            "sbg:revision": 2
          },
          {
            "sbg:revisionNotes": "Copy of uros_sipetic/sciclone-1-1/sciclone-1-1/36",
            "sbg:modifiedBy": "uros_sipetic",
            "sbg:modifiedOn": 1473848949,
            "sbg:revision": 3
          },
          {
            "sbg:revisionNotes": "Copy of uros_sipetic/sciclone-1-1/sciclone-1-1/37",
            "sbg:modifiedBy": "uros_sipetic",
            "sbg:modifiedOn": 1473870296,
            "sbg:revision": 4
          },
          {
            "sbg:revisionNotes": null,
            "sbg:modifiedBy": "uros_sipetic",
            "sbg:modifiedOn": 1478616745,
            "sbg:revision": 5
          },
          {
            "sbg:revisionNotes": null,
            "sbg:modifiedBy": "uros_sipetic",
            "sbg:modifiedOn": 1480511332,
            "sbg:revision": 6
          },
          {
            "sbg:revisionNotes": "Fix boolean parameters with default True values.",
            "sbg:modifiedBy": "uros_sipetic",
            "sbg:modifiedOn": 1485533808,
            "sbg:revision": 7
          },
          {
            "sbg:revisionNotes": "Stage regionsToExclude input.",
            "sbg:modifiedBy": "uros_sipetic",
            "sbg:modifiedOn": 1485950414,
            "sbg:revision": 8
          },
          {
            "sbg:revisionNotes": null,
            "sbg:modifiedBy": "uros_sipetic",
            "sbg:modifiedOn": 1485952823,
            "sbg:revision": 9
          },
          {
            "sbg:revisionNotes": "Add purity estimation.",
            "sbg:modifiedBy": "uros_sipetic",
            "sbg:modifiedOn": 1485955194,
            "sbg:revision": 10
          },
          {
            "sbg:revisionNotes": null,
            "sbg:modifiedBy": "uros_sipetic",
            "sbg:modifiedOn": 1485957576,
            "sbg:revision": 11
          },
          {
            "sbg:revisionNotes": null,
            "sbg:modifiedBy": "uros_sipetic",
            "sbg:modifiedOn": 1485959404,
            "sbg:revision": 12
          },
          {
            "sbg:revisionNotes": null,
            "sbg:modifiedBy": "uros_sipetic",
            "sbg:modifiedOn": 1486039575,
            "sbg:revision": 13
          },
          {
            "sbg:revisionNotes": null,
            "sbg:modifiedBy": "uros_sipetic",
            "sbg:modifiedOn": 1486044713,
            "sbg:revision": 14
          },
          {
            "sbg:revisionNotes": null,
            "sbg:modifiedBy": "uros_sipetic",
            "sbg:modifiedOn": 1486045829,
            "sbg:revision": 15
          },
          {
            "sbg:revisionNotes": null,
            "sbg:modifiedBy": "uros_sipetic",
            "sbg:modifiedOn": 1486046529,
            "sbg:revision": 16
          },
          {
            "sbg:revisionNotes": null,
            "sbg:modifiedBy": "uros_sipetic",
            "sbg:modifiedOn": 1486052585,
            "sbg:revision": 17
          },
          {
            "sbg:revisionNotes": null,
            "sbg:modifiedBy": "uros_sipetic",
            "sbg:modifiedOn": 1486056017,
            "sbg:revision": 18
          },
          {
            "sbg:revisionNotes": null,
            "sbg:modifiedBy": "uros_sipetic",
            "sbg:modifiedOn": 1486063432,
            "sbg:revision": 19
          },
          {
            "sbg:revisionNotes": null,
            "sbg:modifiedBy": "uros_sipetic",
            "sbg:modifiedOn": 1486492364,
            "sbg:revision": 20
          }
        ],
        "sbg:categories": [
          "Tumor-heterogeneity",
          "Tumor-sub-clonality"
        ],
        "hints": [
          {
            "class": "sbg:CPURequirement",
            "value": 1
          },
          {
            "class": "sbg:MemRequirement",
            "value": 1000
          },
          {
            "class": "DockerRequirement",
            "dockerPull": "images.sbgenomics.com/uros_sipetic/sciclone:1.1",
            "dockerImageId": ""
          }
        ],
        "sbg:contributors": [
          "uros_sipetic"
        ],
        "label": "SciClone 1.1",
        "sbg:license": "Apache License 2.0",
        "sbg:validationErrors": [],
        "sbg:links": [
          {
            "id": "https://www.biostars.org/t/sciclone/",
            "label": "Homepage"
          },
          {
            "id": "https://github.com/genome/sciclone",
            "label": "Source Code"
          },
          {
            "id": "https://github.com/genome/sciclone/archive/1.1.tar.gz",
            "label": "Download"
          },
          {
            "id": "http://www.ncbi.nlm.nih.gov/pmc/articles/PMC4125065/",
            "label": "Publication"
          },
          {
            "id": "https://github.com/genome/sciclone/blob/master/man/sciClone.Rd",
            "label": "Documentation"
          }
        ],
        "sbg:job": {
          "allocatedResources": {
            "mem": 1000,
            "cpu": 1
          },
          "inputs": {
            "useSexChrs": "FALSE",
            "copyNumberCalls": [
              {
                "path": "/path/to/sample1.cnvs-1.ext",
                "size": 0,
                "secondaryFiles": [],
                "class": "File"
              },
              {
                "path": "/path/to/sample2.cnvs-2.ext",
                "size": 0,
                "secondaryFiles": [],
                "class": "File"
              },
              {
                "path": "/path/to/sample3.cnvs-3.ext",
                "size": 0,
                "secondaryFiles": [],
                "class": "File"
              }
            ],
            "copyNumberMargins": 4.545060807701435,
            "minimumDepth": 100,
            "control_freec": false,
            "clusterMethod": "bmm",
            "vafs": [
              {
                "path": "/path/to/sample1.vafs-1.ext",
                "size": 0,
                "secondaryFiles": [],
                "class": "File"
              },
              {
                "path": "/path/to/sample2.vafs-2.ext",
                "size": 0,
                "secondaryFiles": [],
                "class": "File"
              },
              {
                "path": "/path/to/sample3.vafs-3.ext"
              }
            ],
            "maximumClusters": 6,
            "cnCallsAreLog2": true,
            "regionsToExclude": [
              {
                "path": "/path/to/sample1.exclude.txt",
                "size": 0,
                "secondaryFiles": [],
                "class": "File"
              },
              {
                "path": "/path/to/sample2.exclude.txt",
                "size": 0,
                "secondaryFiles": [],
                "class": "File"
              },
              {
                "path": "/path/to/sample3.exclude.txt",
                "size": 0,
                "secondaryFiles": [],
                "class": "File"
              }
            ],
            "cnv_kit": true,
            "doClustering": "FALSE"
          }
        },
        "description": "SciClone identifies sub-clones within a sequenced sample. The software integrates read depth and copy number information at single nucleotide variant locations and clusters the variants in copy neutral regions, to formalize description of the sub-clonal architecture of the sample. \n\nThe input files are:\n\n1. VAF files, which can be parsed from most VCF files - required.\n\n2. CNV files, which can be obtained from most CNV callers - optional, but highly recommended. \n\n3. LOH files, regions to be excluded, which can be obtained from tools like Varscan2 - optional, recommended to increase accuracy.\n\n### Common Issues ###\n\n1. All output files will be prefixed by the name of the first sample supplied to the tool. \n\n2. Make sure you correctly parse the VCF files to the proper input VAF files using the SBG SciClone VCF parser tool. \n\n3. The 3D rgl R plot currently does not work due to docker 3D plotting limitations.",
        "stdout": "",
        "sbg:toolkit": "SciClone",
        "sbg:toolkitVersion": "1.1",
        "sbg:revision": 20,
        "sbg:id": "uros_sipetic/sciclone-1-1-demo/sciclone-1-1/20",
        "sbg:modifiedOn": 1486492364,
        "requirements": [
          {
            "class": "CreateFileRequirement",
            "fileDef": [
              {
                "filename": "sciClone.R",
                "fileContent": {
                  "script": "{\n  var COMMAND = \"library(sciClone)\\n\"\n  \n  //read in vaf data from three related tumors\n  //format is 5 column, tab delimited: \n  //chr, pos, ref_reads, var_reads, vaf\n  x = [].concat($job.inputs.vafs)\n  for (i=0; i<x.length; i++) {\n    y = x[i].path.split('/').pop()\n    z = \"v\" + (i+1) + \" = read.table('\" + y + \"',header=F);\\n\"\n    COMMAND += z\n  }\n  \n  //read in regions to exclude (commonly LOH)\n  //format is 3-col bed\n  regions_flag = false\n  if ($job.inputs.regionsToExclude) {\n  regions_flag = true\n  x = [].concat($job.inputs.regionsToExclude)\n  for (i=0; i<x.length; i++) {\n    y = x[i].path.split('/').pop()\n    z = \"regions\" + (i+1) + \" = read.table('\" + y + \"');\\n\"\n    COMMAND += z\n  }\n  }\n  \n  //read in segmented copy number data\n  //4 columns - chr, start, stop, segment_mean\n  cn_flag = false\n  if ($job.inputs.copyNumberCalls) {\n  cn_flag = true\n  x = [].concat($job.inputs.copyNumberCalls)\n  for (i=0; i<x.length; i++) {\n    y = x[i].path.split('/').pop()\n    z = \"cn\" + (i+1) + \" = read.table('\" + y + \"',header=T);\\n\"\n    COMMAND += z\n  }\n  if ($job.inputs.control_freec) {\n    for (i=0; i<x.length; i++) {\n      y = '[,c(1,2,3,4)]'\n      z = \"cn\" + (i+1) + \" = cn\" + (i+1) + y + \";\\n\"\n      COMMAND += z\n  }\n  }\n  if ($job.inputs.cnv_kit) {\n    for (i=0; i<x.length; i++) {\n      y = '[,c(1,2,3,8)]'\n      z = \"cn\" + (i+1) + \" = cn\" + (i+1) + y + \";\\n\"\n      COMMAND += z\n  }\n  }  \n  }\n  //set sample names\n  x = [].concat($job.inputs.vafs)\n  s = []\n  for (i=0; i<x.length; i++) {\n    y = x[i].path.split('/').pop().split('.')\n    s[i] = ''\n    for (j=0; j<y.length-1; j++) {\n      if (j<y.length-2) {\n        s[i] = s[i] + y[j] + \".\"\n      } else {\n        s[i] = s[i] + y[j]\n      }\n    }\n  }\n  z = \"names = c(\"\n  for (i=0; i<s.length; i++) {\n    if (i<s.length-1) {\n      z = z + \"'\" + s[i] + \"',\"\n    } else {\n      z = z + \"'\" + s[i] + \"');\\n\"\n    }\n  }\n  COMMAND += z\n  \n  //do clustering\n  vafs = ''\n  copyNumberCalls = ''\n  regionsToExclude = ''\n  x = [].concat($job.inputs.regionsToExclude)\n  for (i=0; i<x.length;i++) {\n    if (i<x.length-1) {\n      regionsToExclude += 'regions' + (i+1) + ','\n    } else {\n      regionsToExclude += 'regions' + (i+1)\n    }\n  }\n  x = [].concat($job.inputs.copyNumberCalls)\n  for (i=0; i<x.length;i++) {\n    if (i<x.length-1) {\n      copyNumberCalls += 'cn' + (i+1) + ','\n    } else {\n      copyNumberCalls += 'cn' + (i+1)\n    }\n  }\n  x = [].concat($job.inputs.vafs)\n  for (i=0; i<x.length;i++) {\n    if (i<x.length-1) {\n      vafs += 'v' + (i+1) + ','\n    } else {\n      vafs += 'v' + (i+1)\n    }\n  }\n  z = \"sc = sciClone(vafs=list(\" + vafs + \"),\\n\\\n\t\t   sampleNames=names[1:\" + x.length + \"]\"\n  if (cn_flag) {\n    z += \",\\n\\\n\t\t   copyNumberCalls=list(\" + copyNumberCalls + \")\"\n  }\n  if ($job.inputs.minimumDepth) {\n    x = $job.inputs.minimumDepth\n    z += \",\\n\\\n\t\t   minimumDepth=\" + x\n  }\n  if ($job.inputs.maximumClusters) {\n    x = $job.inputs.maximumClusters\n    z += \",\\n\\\n\t\t   maximumClusters=\" + x\n  }\n  if ($job.inputs.cnCallsAreLog2) {\n    x = $job.inputs.cnCallsAreLog2\n    z += \",\\n\\\n\t\t   cnCallsAreLog2=\" + String(x).toUpperCase()\n  }\n  if ($job.inputs.useSexChrs) {\n    x = $job.inputs.useSexChrs\n    z += \",\\n\\\n\t\t   useSexChrs=\" + String(x).toUpperCase()\n  }\n  if ($job.inputs.doClustering) {\n    x = $job.inputs.doClustering\n    z += \",\\n\\\n\t\t   doClustering=\" + String(x).toUpperCase()\n  }\n  if ($job.inputs.copyNumberMargins) {\n    x = $job.inputs.copyNumberMargins\n    z += \",\\n\\\n\t\t   copyNumberMargins=\" + x\n  }\n  if ($job.inputs.clusterMethod) {\n    x = $job.inputs.clusterMethod\n    z += \",\\n\\\n\t\t   clusterMethod='\" + x + \"'\"\n  }\n  \n  if (regions_flag) {\n    z += \",\\n\\\n\t\t   regionsToExclude=list(\" + regionsToExclude + \"));\\n\"\n  } else {\n    z += \");\\n\"\n  }\n  COMMAND += z\n  \n  //produce and plot results\n  x = [].concat($job.inputs.vafs)[0].path.split('/').pop().split('.')\n  y = \"\"\n  for (i=0; i<x.length-1; i++) {\n      if (i<x.length-2) {\n        y += x[i] + \".\"\n      } else {\n        y += x[i]\n      }\n    }\n  z = \"writeClusterTable(sc,'\" + y + \".clusters');\\n\"\n  z += \"writeClusterSummaryTable(sc,'\" + y + \".cluster.summary');\\n\"\n  z += \"sc.plot1d(sc,'\" + y + \".clusters.1d.pdf');\\n\"\n  x = [].concat($job.inputs.vafs)\n  if (x.length>1) {\n    z += \"sc.plot2d(sc,'\" + y + \".clusters.2d.pdf');\\n\"\n    if (x.length==3) {\n      z += \"sc.plot3d(sc,sc@sampleNames,size=700,outputFile='\" + y + \".clusters.3d.gif');\\n\"\n    }\n  }\n  COMMAND += z\n  \n  //write tumor purity to a file\n  z = \"sink('\" + y + \".estimated_tumor_purity.txt');\\n\"\n  z += \"print(paste('Estimated sample tumor purity by SciClones method of evaluating cluster peaks is',sc@purities,'[EXPERIMENTAL]'));\\n\"\n  z += \"sink();\\n\"\n  COMMAND += z\n  \n  //return whole script\n  return COMMAND\n}",
                  "class": "Expression",
                  "engine": "#cwl-js-engine"
                }
              }
            ]
          },
          {
            "requirements": [
              {
                "class": "DockerRequirement",
                "dockerPull": "rabix/js-engine"
              }
            ],
            "id": "#cwl-js-engine",
            "class": "ExpressionEngineRequirement"
          }
        ],
        "class": "CommandLineTool",
        "sbg:sbgMaintained": false,
        "x": 1162.5001681645758,
        "y": 310.98485532673897,
        "cwlVersion": "sbg:draft-2",
        "sbg:image_url": null,
        "inputs": [
          {
            "sbg:stageInput": "link",
            "sbg:category": "Arguments",
            "description": "A list of dataframes containing variant allele fraction data for single nucleotide variants in 5-column format: 1. chromosome 2. position 3.reference-supporting read counts 4. variant-supporting read counts 5. variant allele fraction (between 0-100).",
            "required": true,
            "id": "#vafs",
            "sbg:fileTypes": "VAF,DAT,VCF",
            "type": [
              {
                "items": "File",
                "type": "array",
                "name": "vafs"
              }
            ],
            "label": "Variant allele fraction data"
          },
          {
            "sbg:category": "Arguments",
            "sbg:toolDefaultValue": "TRUE",
            "description": "Boolean argument to specify preference of whether or not to use variants on sex chromosomes in the clustering steps of the tool.",
            "id": "#useSexChrs",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "useSexChrs",
                "symbols": [
                  "TRUE",
                  "FALSE"
                ]
              }
            ],
            "label": "Use sex chromosomes"
          },
          {
            "sbg:stageInput": "link",
            "sbg:category": "Arguments",
            "description": "Exclusions of regions in 3-column format: 1. chromosome 2. window star position 3. window stop position. Single nucleotide variants falling into these windows will not be included in the analysis. Use this input for LOH regions for example.",
            "required": false,
            "id": "#regionsToExclude",
            "sbg:fileTypes": "LOH,TXT",
            "type": [
              "null",
              {
                "items": "File",
                "type": "array"
              }
            ],
            "label": "Regions to be excluded"
          },
          {
            "sbg:stageInput": null,
            "sbg:category": "Arguments",
            "sbg:toolDefaultValue": "100",
            "description": "Threshold used for excluding low-depth variants.",
            "id": "#minimumDepth",
            "type": [
              "null",
              "int"
            ],
            "label": "Minimum depth"
          },
          {
            "sbg:stageInput": null,
            "sbg:category": "Arguments",
            "sbg:toolDefaultValue": "10",
            "description": "Max number for clusters to consider when choosing the component fit to the data.",
            "id": "#maximumClusters",
            "type": [
              "null",
              "int"
            ],
            "label": "Maximum clusters"
          },
          {
            "sbg:stageInput": null,
            "sbg:category": "Arguments",
            "sbg:toolDefaultValue": "TRUE",
            "description": "If TRUE, the tool will attempt to use clustering to identify subclones. If FALSE, this stage is skipped and an object suitable for feeding into the plotting functions is produced.",
            "id": "#doClustering",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "doClustering",
                "symbols": [
                  "TRUE",
                  "FALSE"
                ]
              }
            ],
            "label": "Do clustering"
          },
          {
            "sbg:stageInput": null,
            "sbg:category": "Arguments",
            "sbg:toolDefaultValue": "0.25",
            "description": "In order to identify cleanly copy-number neutral regions, sciClone only considers sites with a copy number of 2.0 +/- this value. For example, if set to 0.25 (which is the default value), regions at 2.20 will be considered cn-neutral and regions at 2.30 will be not.",
            "id": "#copyNumberMargins",
            "type": [
              "null",
              "float"
            ],
            "label": "Copy Number Margins"
          },
          {
            "sbg:stageInput": "link",
            "sbg:category": "Arguments",
            "description": "A list of dataframes containing copy number segments in 4-column format: 1. chromosome 2. segment start position 3. segment stop position 4. copy number value for that segment. Unrepresented regions are assumed to have a copy number of 2.",
            "required": false,
            "id": "#copyNumberCalls",
            "sbg:fileTypes": "CNV,CNS,TXT",
            "type": [
              "null",
              {
                "items": "File",
                "type": "array",
                "name": "copyNumberCalls"
              }
            ],
            "label": "Copy number segments"
          },
          {
            "sbg:stageInput": null,
            "sbg:category": "Arguments",
            "description": "This is a boolean argument which you should specify only if your CN data came from the Control-FREEC tool, in order to parse the resulting files properly.",
            "id": "#control_freec",
            "type": [
              "null",
              "boolean"
            ],
            "label": "Control-FREEC for CN data"
          },
          {
            "id": "#cnv_kit",
            "sbg:category": "Arguments",
            "type": [
              "null",
              "boolean"
            ],
            "description": "This is a boolean argument which you should specify only if your CN data came from the CNVkit tool, in order to parse the resulting files properly.",
            "label": "CNVkit for CN data"
          },
          {
            "sbg:stageInput": null,
            "sbg:category": "Arguments",
            "sbg:toolDefaultValue": "False",
            "description": "Boolean argument specifying whether or not the copy number predictions are in log2 format (as opposed to being absolute copy number designations).",
            "id": "#cnCallsAreLog2",
            "type": [
              "null",
              "boolean"
            ],
            "label": "Copy numbers in log2 format"
          },
          {
            "sbg:stageInput": null,
            "sbg:category": "Arguments",
            "sbg:toolDefaultValue": "bmm",
            "description": "Use a different distribution for clustering. Currently supported options are 'bmm' for beta, 'gaussian.bmm' for gaussian and 'binomial.bmm' for binomial.",
            "id": "#clusterMethod",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "clusterMethod",
                "symbols": [
                  "bmm",
                  "gaussian.bmm",
                  "binomial.bmm"
                ]
              }
            ],
            "label": "Cluster method"
          }
        ],
        "sbg:modifiedBy": "uros_sipetic",
        "successCodes": [],
        "baseCommand": [
          "Rscript",
          "--vanilla",
          "sciClone.R"
        ]
      },
      "inputs": [
        {
          "id": "#SciClone_1_1.vafs",
          "source": [
            "#SBG_SciClone_VCF_parser.vafs"
          ]
        },
        {
          "id": "#SciClone_1_1.useSexChrs",
          "source": [
            "#useSexChrs"
          ]
        },
        {
          "id": "#SciClone_1_1.regionsToExclude",
          "source": [
            "#SBG_SciClone_VCF_parser.regions_to_exclude"
          ]
        },
        {
          "id": "#SciClone_1_1.minimumDepth",
          "source": [
            "#minimumDepth"
          ]
        },
        {
          "id": "#SciClone_1_1.maximumClusters"
        },
        {
          "id": "#SciClone_1_1.doClustering"
        },
        {
          "id": "#SciClone_1_1.copyNumberMargins",
          "source": [
            "#copyNumberMargins"
          ]
        },
        {
          "id": "#SciClone_1_1.copyNumberCalls",
          "source": [
            "#copyNumberCalls"
          ]
        },
        {
          "id": "#SciClone_1_1.control_freec",
          "source": [
            "#control_freec"
          ]
        },
        {
          "id": "#SciClone_1_1.cnv_kit",
          "source": [
            "#cnv_kit"
          ]
        },
        {
          "id": "#SciClone_1_1.cnCallsAreLog2",
          "source": [
            "#cnCallsAreLog2"
          ]
        },
        {
          "id": "#SciClone_1_1.clusterMethod",
          "source": [
            "#clusterMethod"
          ]
        }
      ]
    },
    {
      "sbg:x": 734.9999734629756,
      "outputs": [
        {
          "id": "#VCFtools_Merge.output_file"
        }
      ],
      "id": "#VCFtools_Merge",
      "sbg:y": 279.28624692170513,
      "run": {
        "sbg:cmdPreview": "bgzip -c -f sample2.realigned.vcf > sample2.realigned.vcf.gz && tabix -f sample2.realigned.vcf.gz && bgzip -c -f custard.realigned.vcf > custard.realigned.vcf.gz && tabix -f custard.realigned.vcf.gz && vcf-merge sample2.realigned.vcf.gz custard.realigned.vcf.gz   > sample_unknown_.realigned.merged.vcf",
        "sbg:createdOn": 1450911605,
        "sbg:createdBy": "bix-demo",
        "stdin": "",
        "sbg:toolAuthor": "Adam Auton, Petr Danecek, Anthony Marcketta",
        "outputs": [
          {
            "outputBinding": {
              "glob": {
                "script": "{\n  arr = [].concat($job.inputs.input_files);\n  \n  function common_end(strs) {\n  \n  \t// Find minimum length of file name\n  \n  \tls = [];\n    whole = [];\n\tfor (i=0;i<strs.length;i++){\n  \t\tls = ls.concat(strs[i].path.split('/').pop().length);\n        whole = whole.concat(strs[i].path.length);\n  \t}\n \tl = Math.min.apply(Math,ls);\n  \n  \t// Loop from the end through characters and check if they are the same for all\n  \n \tind = 0;\n \tflag = 0;\n \tfor (i=1;i<=l;i++){\n    \tfor (j=1;j<strs.length;j++){\n      \t\tif (strs[0].path[whole[0]-i]!=strs[j].path[whole[j]-i]){\n        \tflag = 1;\n        \tbreak\n      \t\t}\n   \t\t}\n   \t \tif (flag == 1){\n   \t \t  \tbreak\n   \t    } else {\n      \t\tind = ind + 1;\n        }\n  \t }\n  \n  // Assign and return longest ending common substring\n  if (ind>0) {\n  \tcomstr = strs[0].path.slice(-ind);\n  } else {\n    comstr = 'different_extensions'\n  }\n  \n  return comstr\n  \n  }\n  \n  \n  if(arr.length==1) { \n    new_filename = arr[0].path.split('/').pop()    \n  } else {\n\n    if (arr[0].metadata){  \n \t \t  if (arr[0].metadata[\"sample_id\"]){        \n  \t\t\t prefix = arr[0].metadata[\"sample_id\"];   \n   \t\t  } else {\n   \t\t\t prefix = 'sample_unknown';\n \t      }\n    } else {\n      \n     prefix = 'sample_unknown';\n      \n    }\n\n  \n  // Create joint name and add the merged suffix\n  \n  joint_name = prefix + '_' + common_end(arr);\n  new_filename = joint_name.split('.').slice(0,-1).join('.') + '.merged.vcf'\n  \n  }\n  \n  if ($job.inputs.compressed){\n    new_filename += '.gz'\n  }\n  \n  return new_filename\n\n}",
                "class": "Expression",
                "engine": "#cwl-js-engine"
              },
              "secondaryFiles": [
                ".tbi"
              ]
            },
            "description": "Merged vcf files from the input.",
            "id": "#output_file",
            "sbg:fileTypes": "VCF,VCF.GZ",
            "type": [
              "null",
              "File"
            ],
            "label": "Output file merged vcfs"
          }
        ],
        "temporaryFailCodes": [],
        "id": "bix-demo/vcftools-0-1-14-demo/vcftools-merge-0-1-14/13",
        "sbg:latestRevision": 13,
        "sbg:projectName": "VCFtools 0.1.14 - Demo",
        "sbg:project": "bix-demo/vcftools-0-1-14-demo",
        "sbg:appVersion": [
          "sbg:draft-2"
        ],
        "arguments": [
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  arr = [].concat($job.inputs.input_files);\n  \n  function common_end(strs) {\n  \n  \t// Find minimum length of file name\n  \n  \tls = [];\n    whole = [];\n\tfor (i=0;i<strs.length;i++){\n  \t\tls = ls.concat(strs[i].path.split('/').pop().length);\n        whole = whole.concat(strs[i].path.length);\n  \t}\n \tl = Math.min.apply(Math,ls);\n  \n  \t// Loop from the end through characters and check if they are the same for all\n  \n \tind = 0;\n \tflag = 0;\n \tfor (i=1;i<=l;i++){\n    \tfor (j=1;j<strs.length;j++){\n      \t\tif (strs[0].path[whole[0]-i]!=strs[j].path[whole[j]-i]){\n        \tflag = 1;\n        \tbreak\n      \t\t}\n   \t\t}\n   \t \tif (flag == 1){\n   \t \t  \tbreak\n   \t    } else {\n      \t\tind = ind + 1;\n        }\n  \t }\n  \n  // Assign and return longest ending common substring\n  if (ind>0) {\n  \tcomstr = strs[0].path.slice(-ind);\n  } else {\n    comstr = 'different_extensions'\n  }\n  \n  return comstr\n  \n  }\n  \n  \n  if(arr.length==1) { \n    new_filename = arr[0].path.split('/').pop()    \n  } else {\n\n    if (arr[0].metadata){  \n \t \t  if (arr[0].metadata[\"sample_id\"]){        \n  \t\t\t prefix = arr[0].metadata[\"sample_id\"];   \n   \t\t  } else {\n   \t\t\t prefix = 'sample_unknown';\n \t      }\n    } else {\n      \n     prefix = 'sample_unknown';\n      \n    }\n\n  \n  // Create joint name and add the merged suffix\n  \n  joint_name = prefix + '_' + common_end(arr);\n  new_filename = joint_name.split('.').slice(0,-1).join('.') + '.merged.vcf'\n  \n  }\n\n    return  '> ' + new_filename;\n\n\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            },
            "position": 20
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  \n  com = ''\n  if ($job.inputs.compressed) {\n  \n  arr = [].concat($job.inputs.input_files);\n  \n  function common_end(strs) {\n  \n  \t// Find minimum length of file name\n  \n  \tls = [];\n    whole = [];\n\tfor (i=0;i<strs.length;i++){\n  \t\tls = ls.concat(strs[i].path.split('/').pop().length);\n        whole = whole.concat(strs[i].path.length);\n  \t}\n \tl = Math.min.apply(Math,ls);\n  \n  \t// Loop from the end through characters and check if they are the same for all\n  \n \tind = 0;\n \tflag = 0;\n \tfor (i=1;i<=l;i++){\n    \tfor (j=1;j<strs.length;j++){\n      \t\tif (strs[0].path[whole[0]-i]!=strs[j].path[whole[j]-i]){\n        \tflag = 1;\n        \tbreak\n      \t\t}\n   \t\t}\n   \t \tif (flag == 1){\n   \t \t  \tbreak\n   \t    } else {\n      \t\tind = ind + 1;\n        }\n  \t }\n  \n  // Assign and return longest ending common substring\n  if (ind>0) {\n  \tcomstr = strs[0].path.slice(-ind);\n  } else {\n    comstr = 'different_extensions'\n  }\n  \n  return comstr\n  \n  }\n  \n  \n  if(arr.length==1) { \n    new_filename = arr[0].path.split('/').pop()    \n  } else {\n\n    if (arr[0].metadata){  \n \t \t  if (arr[0].metadata[\"sample_id\"]){        \n  \t\t\t prefix = arr[0].metadata[\"sample_id\"];   \n   \t\t  } else {\n   \t\t\t prefix = 'sample_unknown';\n \t      }\n    } else {\n      \n     prefix = 'sample_unknown';\n      \n    }\n\n  \n  // Create joint name and add the merged suffix\n  \n  joint_name = prefix + '_' + common_end(arr);\n  new_filename = joint_name.split('.').slice(0,-1).join('.') + '.merged.vcf'\n  \n  }\n\n   com += '&& bgzip -c -f '\n   com += new_filename\n   com += ' > ' + new_filename + '.gz'\n\n  }\n  return com\n\n\n}\n    \n\n",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            },
            "position": 25
          }
        ],
        "sbg:revisionsInfo": [
          {
            "sbg:revisionNotes": null,
            "sbg:modifiedBy": "bix-demo",
            "sbg:modifiedOn": 1450911605,
            "sbg:revision": 0
          },
          {
            "sbg:revisionNotes": null,
            "sbg:modifiedBy": "bix-demo",
            "sbg:modifiedOn": 1450911605,
            "sbg:revision": 1
          },
          {
            "sbg:revisionNotes": null,
            "sbg:modifiedBy": "bix-demo",
            "sbg:modifiedOn": 1450911606,
            "sbg:revision": 2
          },
          {
            "sbg:revisionNotes": null,
            "sbg:modifiedBy": "bix-demo",
            "sbg:modifiedOn": 1450911606,
            "sbg:revision": 3
          },
          {
            "sbg:revisionNotes": null,
            "sbg:modifiedBy": "bix-demo",
            "sbg:modifiedOn": 1450911607,
            "sbg:revision": 4
          },
          {
            "sbg:revisionNotes": null,
            "sbg:modifiedBy": "bix-demo",
            "sbg:modifiedOn": 1450911608,
            "sbg:revision": 5
          },
          {
            "sbg:revisionNotes": "Fixed formatting.",
            "sbg:modifiedBy": "ognjenm",
            "sbg:modifiedOn": 1472815584,
            "sbg:revision": 6
          },
          {
            "sbg:revisionNotes": "Changed collapse to enum",
            "sbg:modifiedBy": "ognjenm",
            "sbg:modifiedOn": 1472818436,
            "sbg:revision": 7
          },
          {
            "sbg:revisionNotes": "Corrected filename?",
            "sbg:modifiedBy": "ognjenm",
            "sbg:modifiedOn": 1473083966,
            "sbg:revision": 8
          },
          {
            "sbg:revisionNotes": "Changed errors for multiple files",
            "sbg:modifiedBy": "ognjenm",
            "sbg:modifiedOn": 1473092601,
            "sbg:revision": 9
          },
          {
            "sbg:revisionNotes": "Made compressible output",
            "sbg:modifiedBy": "ognjenm",
            "sbg:modifiedOn": 1473862403,
            "sbg:revision": 10
          },
          {
            "sbg:revisionNotes": "Inputs are possibly GZ",
            "sbg:modifiedBy": "ognjenm",
            "sbg:modifiedOn": 1473867928,
            "sbg:revision": 11
          },
          {
            "sbg:revisionNotes": "Linked input",
            "sbg:modifiedBy": "ognjenm",
            "sbg:modifiedOn": 1473869322,
            "sbg:revision": 12
          },
          {
            "sbg:revisionNotes": "Fixed error --ref-for-missing",
            "sbg:modifiedBy": "ognjenm",
            "sbg:modifiedOn": 1493121667,
            "sbg:revision": 13
          }
        ],
        "sbg:categories": [
          "VCF-Processing"
        ],
        "hints": [
          {
            "class": "DockerRequirement",
            "dockerPull": "images.sbgenomics.com/ognjenm/vcftools:0.1.14",
            "dockerImageId": "54cb823ba25a"
          },
          {
            "class": "sbg:CPURequirement",
            "value": 1
          },
          {
            "class": "sbg:MemRequirement",
            "value": 1000
          }
        ],
        "sbg:contributors": [
          "ognjenm",
          "bix-demo"
        ],
        "label": "VCFtools Merge",
        "sbg:license": "GNU General Public License version 3.0 (GPLv3)",
        "sbg:validationErrors": [],
        "sbg:links": [
          {
            "id": "https://vcftools.github.io",
            "label": "Homepage"
          },
          {
            "id": "https://github.com/vcftools/vcftools/zipball/master",
            "label": "Download"
          },
          {
            "id": "http://bioinformatics.oxfordjournals.org/content/27/15/2156",
            "label": "Publication"
          },
          {
            "id": "https://sourceforge.net/p/vcftools/wiki/Home/",
            "label": "Wiki"
          },
          {
            "id": "https://github.com/vcftools/vcftools/blob/master/src/perl/vcf-merge",
            "label": "Source Code"
          }
        ],
        "sbg:job": {
          "allocatedResources": {
            "mem": 1000,
            "cpu": 1
          },
          "inputs": {
            "trim": false,
            "input_files": [
              {
                "path": "sample2.realigned.vcf",
                "size": 0,
                "secondaryFiles": [],
                "class": "File"
              },
              {
                "path": "custard.realigned.vcf",
                "size": 0,
                "secondaryFiles": [],
                "class": "File"
              }
            ],
            "ref_for_missing": "",
            "collapse": null,
            "remove_duplicates": false,
            "silent": false,
            "compressed": false,
            "vcf_header": {
              "path": "vcf.cf",
              "size": 0,
              "secondaryFiles": [],
              "class": "File"
            }
          }
        },
        "description": "VCFtools merge merges two or more VCF files into one so that if two source files had one column each, the output will print a single file with two columns. \nNote that this script is not intended for concatenating VCF files. For this, use vcf-concat instead.",
        "stdout": "",
        "sbg:toolkit": "VCFtools",
        "sbg:toolkitVersion": "0.1.14",
        "sbg:revisionNotes": "Fixed error --ref-for-missing",
        "sbg:revision": 13,
        "sbg:id": "bix-demo/vcftools-0-1-14-demo/vcftools-merge-0-1-14/13",
        "sbg:modifiedOn": 1493121667,
        "requirements": [
          {
            "requirements": [
              {
                "class": "DockerRequirement",
                "dockerPull": "rabix/js-engine"
              }
            ],
            "id": "#cwl-js-engine",
            "class": "ExpressionEngineRequirement",
            "engineCommand": "cwl-engine.js"
          }
        ],
        "class": "CommandLineTool",
        "sbg:sbgMaintained": false,
        "x": 734.9999734629756,
        "y": 279.28624692170513,
        "cwlVersion": "sbg:draft-2",
        "sbg:image_url": null,
        "inputs": [
          {
            "inputBinding": {
              "separate": true,
              "valueFrom": {
                "script": "{\n  \n  arr = [].concat($job.inputs.input_files);\n \n  if (arr.length == 1 || !$job.inputs.vcf_header) {\n    \n    return ''\n    \n  } else {\n\n   \treturn '-H ' + $job.inputs.vcf_header.path\n\n  }\n}",
                "class": "Expression",
                "engine": "#cwl-js-engine"
              },
              "sbg:cmdInclude": true,
              "position": 3
            },
            "sbg:category": "Execution",
            "description": "Use the provided VCF header.",
            "required": false,
            "id": "#vcf_header",
            "sbg:fileTypes": "VCF",
            "type": [
              "null",
              "File"
            ],
            "label": "vcf header file"
          },
          {
            "inputBinding": {
              "separate": false,
              "itemSeparator": null,
              "valueFrom": {
                "script": "{\n  \n  arr = [].concat($job.inputs.input_files);\n \n  if (arr.length == 1) {\n    \n    return ''\n    \n  } else {\n    \n    if ($job.inputs.trim) {\n      \n   \t\treturn '-t'\n    \n    }\n  }\n}",
                "class": "Expression",
                "engine": "#cwl-js-engine"
              },
              "sbg:cmdInclude": true,
              "position": 7
            },
            "sbg:category": "Execution",
            "sbg:toolDefaultValue": "FALSE",
            "description": "If set, redundant ALTs will be removed.",
            "id": "#trim",
            "type": [
              "null",
              "boolean"
            ],
            "label": "Trim"
          },
          {
            "inputBinding": {
              "separate": false,
              "valueFrom": {
                "script": "{\n  \n  arr = [].concat($job.inputs.input_files);\n \n  if (arr.length == 1) {\n    \n    return ''\n    \n  } else {\n    \n    if ($job.inputs.silent) {\n      \n   \t\treturn '-s'\n    \n    }\n  }\n}",
                "class": "Expression",
                "engine": "#cwl-js-engine"
              },
              "sbg:cmdInclude": true,
              "position": 6
            },
            "sbg:category": "Execution",
            "sbg:toolDefaultValue": "FALSE",
            "description": "Try to be a bit more silent, no warnings about duplicate lines.",
            "id": "#silent",
            "type": [
              "null",
              "boolean"
            ],
            "label": "Silent"
          },
          {
            "id": "#remove_duplicates",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "-d",
              "position": 1
            },
            "type": [
              "null",
              "boolean"
            ],
            "description": "If there should be two consecutive rows with the same chr:pos, print only the first one.",
            "label": "Remove duplicates"
          },
          {
            "inputBinding": {
              "separate": true,
              "position": 4,
              "sbg:cmdInclude": true,
              "prefix": "-r",
              "streamable": false
            },
            "sbg:category": "Execution",
            "description": "Do only the given regions (comma-separated list or one region per line in a file).",
            "required": false,
            "id": "#regions",
            "sbg:fileTypes": "TXT",
            "type": [
              "null",
              "File"
            ],
            "label": "Regions"
          },
          {
            "inputBinding": {
              "separate": true,
              "valueFrom": {
                "script": "{\n  \n  arr = [].concat($job.inputs.input_files);\n \n  if (arr.length == 1) {\n    \n    return ''\n    \n  } else {\n    \n    if ($job.inputs.ref_for_missing) {\n   return '--ref-for-missing ' + $job.inputs.ref_for_missing\n    } else {\n      return ''\n    }\n  }\n}",
                "class": "Expression",
                "engine": "#cwl-js-engine"
              },
              "sbg:cmdInclude": true,
              "position": 8
            },
            "sbg:category": "Execution",
            "sbg:toolDefaultValue": "0/0",
            "description": "Use the REF allele instead of the default missing genotype. Because it is not obvious what ploidy should be used, a user-defined string is used instead (e.g. 0/0).",
            "id": "#ref_for_missing",
            "sbg:altPrefix": "-R",
            "type": [
              "null",
              "string"
            ],
            "label": "Ref for missing"
          },
          {
            "sbg:stageInput": "link",
            "inputBinding": {
              "separate": false,
              "itemSeparator": " ",
              "valueFrom": {
                "script": "{\n  \n  com=''\n  \n  for (i = 0; i<$job.inputs.input_files.length; i++) {\n  \n  ext = $job.inputs.input_files[i].path.split('.').pop()\n  \n  \tif (ext == 'vcf') {\n     \n  \t\tcom+=$job.inputs.input_files[i].path.split('/').pop() +'.gz '\n    \n    } else {\n      \n      com+=$job.inputs.input_files[i].path.split('/').pop() + ' '\n      \n    }\n  }\n  return com\n}",
                "class": "Expression",
                "engine": "#cwl-js-engine"
              },
              "sbg:cmdInclude": true,
              "position": 10
            },
            "sbg:category": "File Input",
            "description": "Input files for merging in compressed format (.vcf.gz).",
            "required": true,
            "id": "#input_files",
            "sbg:fileTypes": "VCF,VCF.GZ",
            "type": [
              {
                "items": "File",
                "type": "array",
                "name": "input_files"
              }
            ],
            "label": "Input files"
          },
          {
            "sbg:stageInput": null,
            "sbg:category": "Execution",
            "sbg:toolDefaultValue": "FALSE",
            "description": "Check to make the output compressed (usually for further processing).",
            "id": "#compressed",
            "type": [
              "null",
              "boolean"
            ],
            "label": "Compressed output"
          },
          {
            "inputBinding": {
              "separate": true,
              "valueFrom": {
                "script": "{\n  \n  arr = [].concat($job.inputs.input_files);\n \n  if (arr.length == 1) {\n    \n    return ''\n    \n  } else {\n    \n    if ($job.inputs.collapse) {\n   \t\treturn '--collapse ' + $job.inputs.collapse\n    } else {\n     return '' \n    }\n  }\n}",
                "class": "Expression",
                "engine": "#cwl-js-engine"
              },
              "sbg:cmdInclude": true,
              "position": 2
            },
            "sbg:category": "Execution",
            "sbg:toolDefaultValue": "any",
            "description": "Treat as identical sites with differing alleles [any].",
            "id": "#collapse",
            "sbg:altPrefix": "-c",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "collapse",
                "symbols": [
                  "snps",
                  "indels",
                  "both",
                  "any"
                ]
              }
            ],
            "label": "Collapse"
          }
        ],
        "sbg:modifiedBy": "ognjenm",
        "successCodes": [],
        "baseCommand": [
          {
            "script": "{\n  \n  com=''\n  arr = [].concat($job.inputs.input_files)\n  \n  for (i = 0; i<arr.length; i++) {\n  \n  ext = arr[i].path.split('.').pop()\n  \n    fullname=arr[i].path\n    paths=fullname.split('/')\n\tname = fullname.split('/')[paths.length-1]\n        \n  \tif (ext == 'vcf') {\n     \n        // Bgzipping\n  \t\tcom+='bgzip'\n  \t\tcom+=' -c -f '\n\n  \t\tcom+=fullname\n        name += '.gz'\n        com+=' > '+name\n  \t    com+=' && '\n    \n  \t}\n    \n    // Indexing\n    com+='tabix -f ' + name.split('/').pop()\n    com+=' && '\n    \n  }\n  \n    \tcom+='vcf-merge'\n  \n  return com\n}",
            "class": "Expression",
            "engine": "#cwl-js-engine"
          }
        ]
      },
      "inputs": [
        {
          "id": "#VCFtools_Merge.vcf_header"
        },
        {
          "id": "#VCFtools_Merge.trim"
        },
        {
          "id": "#VCFtools_Merge.silent"
        },
        {
          "id": "#VCFtools_Merge.remove_duplicates"
        },
        {
          "id": "#VCFtools_Merge.regions"
        },
        {
          "id": "#VCFtools_Merge.ref_for_missing"
        },
        {
          "id": "#VCFtools_Merge.input_files",
          "source": [
            "#VCFtools_Sort.output_file"
          ]
        },
        {
          "id": "#VCFtools_Merge.compressed"
        },
        {
          "id": "#VCFtools_Merge.collapse"
        }
      ]
    },
    {
      "sbg:x": 78.64855051650429,
      "outputs": [
        {
          "id": "#VCFtools_Subset.output_file"
        }
      ],
      "id": "#VCFtools_Subset",
      "sbg:y": 309.6429763364672,
      "scatter": "#VCFtools_Subset.input_files",
      "run": {
        "sbg:cmdPreview": "tmp=$(python get_tumor_name.py -i /path/to/sample1.vcf) &&  vcf-subset /path/to/sample1.vcf > sample1.subset.vcf",
        "sbg:createdOn": 1485277623,
        "sbg:createdBy": "uros_sipetic",
        "stdin": "",
        "sbg:toolAuthor": "Adam Auton, Petr Danecek, Anthony Marcketta",
        "outputs": [
          {
            "outputBinding": {
              "sbg:inheritMetadataFrom": "#input_files",
              "glob": {
                "script": "{\n  inp = $job.inputs.input_files\n  inp = [].concat( inp );\n  \n  if (inp.length > 1) {\n     sufix = \"and_more.subset\"\n  } else {\n     sufix = \"subset\"\n  }\n  \n  sufix_ext = \"vcf\";\n  filepath = inp[0].path\n  filename = filepath.split(\"/\").pop()\n  \n  if (filename.lastIndexOf(\".vcf.gz\") != -1) {\n    basename = filename.substr(0,filename.lastIndexOf(\".vcf.gz\"))\n  } else {\n    basename = filename.substr(0,filename.lastIndexOf(\".\"))\n  }\n\n  new_filename = basename + \".\" + sufix + \".\" + sufix_ext;\n  \n  return new_filename;\n}",
                "class": "Expression",
                "engine": "#cwl-js-engine"
              }
            },
            "description": "Output file satisfying the subset criteria.",
            "id": "#output_file",
            "sbg:fileTypes": "VCF",
            "type": [
              "null",
              "File"
            ],
            "label": "Output file"
          }
        ],
        "temporaryFailCodes": [],
        "id": "uros_sipetic/bms-rna-tools/vcftools-subset-0-1-14/4",
        "sbg:latestRevision": 4,
        "sbg:projectName": "BMS RNA Tools",
        "sbg:project": "uros_sipetic/bms-rna-tools",
        "sbg:appVersion": [
          "sbg:draft-2"
        ],
        "arguments": [],
        "sbg:revisionsInfo": [
          {
            "sbg:revisionNotes": "Copy of admin/sbg-public-data/vcftools-subset-0-1-14/10",
            "sbg:modifiedBy": "uros_sipetic",
            "sbg:modifiedOn": 1485277623,
            "sbg:revision": 0
          },
          {
            "sbg:revisionNotes": "Remove the record filed and make all it's fields into separate inputs.",
            "sbg:modifiedBy": "uros_sipetic",
            "sbg:modifiedOn": 1485278116,
            "sbg:revision": 1
          },
          {
            "sbg:revisionNotes": null,
            "sbg:modifiedBy": "uros_sipetic",
            "sbg:modifiedOn": 1485287986,
            "sbg:revision": 2
          },
          {
            "sbg:revisionNotes": null,
            "sbg:modifiedBy": "uros_sipetic",
            "sbg:modifiedOn": 1485288053,
            "sbg:revision": 3
          },
          {
            "sbg:revisionNotes": null,
            "sbg:modifiedBy": "uros_sipetic",
            "sbg:modifiedOn": 1493215351,
            "sbg:revision": 4
          }
        ],
        "sbg:categories": [
          "VCF-Processing"
        ],
        "hints": [
          {
            "class": "DockerRequirement",
            "dockerPull": "images.sbgenomics.com/ognjenm/vcftools:0.1.14",
            "dockerImageId": "54cb823ba25a"
          },
          {
            "class": "sbg:CPURequirement",
            "value": 1
          },
          {
            "class": "sbg:MemRequirement",
            "value": 1000
          }
        ],
        "sbg:contributors": [
          "uros_sipetic"
        ],
        "label": "VCFtools Subset",
        "sbg:license": "GNU General Public License version 3.0 (GPLv3)",
        "sbg:validationErrors": [],
        "sbg:links": [
          {
            "id": "https://vcftools.github.io",
            "label": "Homepage"
          },
          {
            "id": "https://github.com/vcftools/vcftools",
            "label": "Source code"
          },
          {
            "id": "http://bioinformatics.oxfordjournals.org/content/27/15/2156",
            "label": "Publications"
          },
          {
            "id": "https://github.com/vcftools/vcftools/zipball/master",
            "label": "Download"
          },
          {
            "id": "https://sourceforge.net/p/vcftools/wiki/Home/",
            "label": "Wiki"
          }
        ],
        "description": "VCFtools subset removes specified columns from the VCF file.",
        "stdout": {
          "script": "{\n  inp = $job.inputs.input_files\n  inp = [].concat( inp );\n  \n  if (inp.length > 1) {\n     sufix = \"and_more.subset\"\n  } else {\n     sufix = \"subset\"\n  }\n  \n  sufix_ext = \"vcf\";\n  filepath = inp[0].path\n  filename = filepath.split(\"/\").pop()\n  \n  if (filename.lastIndexOf(\".vcf.gz\") != -1) {\n    basename = filename.substr(0,filename.lastIndexOf(\".vcf.gz\"))\n  } else {\n    basename = filename.substr(0,filename.lastIndexOf(\".\"))\n  }\n\n  new_filename = basename + \".\" + sufix + \".\" + sufix_ext;\n  \n  return new_filename;\n}",
          "class": "Expression",
          "engine": "#cwl-js-engine"
        },
        "sbg:toolkit": "VCFtools",
        "sbg:toolkitVersion": "0.1.14",
        "sbg:revision": 4,
        "sbg:id": "uros_sipetic/bms-rna-tools/vcftools-subset-0-1-14/4",
        "sbg:modifiedOn": 1493215351,
        "requirements": [
          {
            "requirements": [
              {
                "class": "DockerRequirement",
                "dockerPull": "rabix/js-engine"
              }
            ],
            "id": "#cwl-js-engine",
            "class": "ExpressionEngineRequirement",
            "engineCommand": "cwl-engine.js"
          },
          {
            "class": "CreateFileRequirement",
            "fileDef": [
              {
                "filename": "get_tumor_name.py",
                "fileContent": "import argparse\n\nparser = argparse.ArgumentParser(description='This tool outputs the tumor name column from a VCF file.')\nparser.add_argument('-i','--input', help='Input VCF file', required=True)\nargs = vars(parser.parse_args())\n\nvcf_file = args['input']\nwith open(vcf_file) as f:\n    for line in f:\n        if line[0:6]=='#CHROM':\n            \n            x = line.split('\\t')\n            tumor_name = x[-1]\n            \n            samples = x[-2:-1]\n            for s in samples:\n                if s.lower() == 'tumor':\n                    tumor_name = s\n                    \n            break\n\nprint tumor_name.rstrip()"
              }
            ]
          }
        ],
        "class": "CommandLineTool",
        "sbg:sbgMaintained": false,
        "x": 78.64855051650429,
        "y": 309.6429763364672,
        "cwlVersion": "sbg:draft-2",
        "sbg:image_url": null,
        "inputs": [
          {
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "-u",
              "position": 8
            },
            "sbg:category": "Execution",
            "sbg:toolDefaultValue": "FALSE",
            "description": "Do not exclude rows without calls.",
            "id": "#uncalled",
            "type": [
              "null",
              "boolean"
            ],
            "label": "Uncalled"
          },
          {
            "sbg:stageInput": null,
            "inputBinding": {
              "separate": true,
              "itemSeparator": ",",
              "sbg:cmdInclude": true,
              "prefix": "-t",
              "position": 7
            },
            "sbg:category": "Execution",
            "description": "Comma-separated list of variant types to include: ref,SNPs,indels,MNPs,other.",
            "id": "#types",
            "type": [
              "null",
              {
                "items": "string",
                "type": "array"
              }
            ],
            "label": "List of variant types"
          },
          {
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "-a",
              "position": 0
            },
            "sbg:category": "Execution",
            "sbg:toolDefaultValue": "FALSE",
            "description": "Remove alternate alleles if not found in the subset.",
            "id": "#trim_alternate_alleles",
            "type": [
              "null",
              "boolean"
            ],
            "label": "Trim alternate alleles"
          },
          {
            "sbg:stageInput": null,
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "-r",
              "position": 5
            },
            "sbg:category": "Execution",
            "description": "Replace the excluded types with reference allele instead of dot.",
            "id": "#replace_with_ref",
            "type": [
              "null",
              "boolean"
            ],
            "label": "Replace with reference"
          },
          {
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "-p",
              "position": 4
            },
            "sbg:category": "Execution",
            "sbg:toolDefaultValue": "FALSE",
            "description": "Print only rows where only the subset columns carry an alternate allele.",
            "id": "#private",
            "type": [
              "null",
              "boolean"
            ],
            "label": "Private"
          },
          {
            "inputBinding": {
              "separate": false,
              "itemSeparator": null,
              "sbg:cmdInclude": true,
              "position": 100
            },
            "sbg:category": "File Input",
            "description": "Input files (vcf, vcf.gz).",
            "required": true,
            "id": "#input_files",
            "sbg:fileTypes": "VCF, VCF.GZ",
            "type": [
              {
                "items": "File",
                "type": "array",
                "name": "input_files"
              }
            ],
            "label": "Input files"
          },
          {
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "-f",
              "position": 3
            },
            "sbg:category": "Execution",
            "sbg:toolDefaultValue": "FALSE",
            "description": "Proceed anyway even if VCF does not contain some of the samples.",
            "id": "#force",
            "type": [
              "null",
              "boolean"
            ],
            "label": "Force execution"
          },
          {
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "-e",
              "position": 2
            },
            "sbg:category": "Execution",
            "sbg:toolDefaultValue": "FALSE",
            "description": "Exclude rows not containing variants.",
            "id": "#exclude_rows",
            "type": [
              "null",
              "boolean"
            ],
            "label": "Exclude rows not containing variants"
          },
          {
            "inputBinding": {
              "itemSeparator": ",",
              "prefix": "-c",
              "valueFrom": {
                "script": "{\n  if ($job.inputs.columns) {\n    return $job.inputs.columns \n  } else {\n    return \"$tmp\"\n  }\n}",
                "class": "Expression",
                "engine": "#cwl-js-engine"
              },
              "separate": true,
              "sbg:cmdInclude": true,
              "position": 1
            },
            "sbg:category": "Execution",
            "description": "File or comma-separated list of columns to keep in the vcf file. If file, one column per row.",
            "id": "#columns",
            "type": [
              "null",
              {
                "items": "string",
                "type": "array"
              }
            ],
            "label": "Comma separated list of columns"
          }
        ],
        "sbg:job": {
          "allocatedResources": {
            "mem": 1000,
            "cpu": 1
          },
          "inputs": {
            "columns": null,
            "input_files": [
              {
                "path": "/path/to/sample1.vcf",
                "size": 0,
                "secondaryFiles": [],
                "class": "File"
              }
            ],
            "types": null,
            "replace_with_ref": false
          }
        },
        "sbg:modifiedBy": "uros_sipetic",
        "successCodes": [],
        "baseCommand": [
          {
            "script": "{\n  var vcf = [].concat($job.inputs.input_files)[0].path\n  return \"tmp=$(python get_tumor_name.py -i \" + vcf + \") && \"\n}",
            "class": "Expression",
            "engine": "#cwl-js-engine"
          },
          "vcf-subset"
        ]
      },
      "inputs": [
        {
          "default": true,
          "id": "#VCFtools_Subset.uncalled"
        },
        {
          "id": "#VCFtools_Subset.types"
        },
        {
          "id": "#VCFtools_Subset.trim_alternate_alleles"
        },
        {
          "id": "#VCFtools_Subset.replace_with_ref"
        },
        {
          "id": "#VCFtools_Subset.private"
        },
        {
          "id": "#VCFtools_Subset.input_files",
          "source": [
            "#VCFtools_Keep_SNPs_or_Indels.output_file"
          ]
        },
        {
          "id": "#VCFtools_Subset.force"
        },
        {
          "id": "#VCFtools_Subset.exclude_rows"
        },
        {
          "id": "#VCFtools_Subset.columns"
        }
      ]
    },
    {
      "sbg:x": 504.70595415900743,
      "outputs": [
        {
          "id": "#VCFtools_Sort.output_file"
        }
      ],
      "id": "#VCFtools_Sort",
      "sbg:y": 309.90198471966914,
      "scatter": "#VCFtools_Sort.input_file",
      "run": {
        "sbg:cmdPreview": "vcf-sort sample1.vcf  > sample1.sorted.vcf  && bgzip -c -f sample1.sorted.vcf > sample1.sorted.vcf.gz",
        "sbg:createdOn": 1453798863,
        "sbg:createdBy": "sevenbridges",
        "stdin": "",
        "sbg:toolAuthor": "Adam Auton, Petr Danecek, Anthony Marcketta",
        "outputs": [
          {
            "id": "#output_file",
            "outputBinding": {
              "sbg:metadata": {
                "__inherit__": "input_file"
              },
              "glob": {
                "script": "{\n  filepath = $job.inputs.input_file.path\n\n  filename = filepath.split(\"/\").pop();\n\n  file_dot_sep = filename.split(\".\");\n  file_ext = file_dot_sep[file_dot_sep.length-1];\n\n  new_filename = filename.substr(0,filename.lastIndexOf(\".vcf\")) + \".sorted.vcf\";\n\n  if ($job.inputs.compressed) {\n      new_filename += \".gz\";\n  }\n  \n  return new_filename;\n  \n}",
                "class": "Expression",
                "engine": "#cwl-js-engine"
              }
            },
            "sbg:fileTypes": "VCF, VCF.GZ",
            "type": [
              "null",
              "File"
            ],
            "label": "Output file"
          }
        ],
        "temporaryFailCodes": [],
        "id": "admin/sbg-public-data/vcftools-sort-0-1-14/5",
        "sbg:latestRevision": 5,
        "sbg:projectName": "SBG Public Data",
        "sbg:project": "admin/sbg-public-data",
        "sbg:appVersion": [
          "sbg:draft-2"
        ],
        "arguments": [
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n\n\n  if ($job.inputs.compressed) {\n    \n  \tfilepath = $job.inputs.input_file.path\n\n  \tfilename = filepath.split(\"/\").pop();\n\n  \tfile_dot_sep = filename.split(\".\");\n  \tfile_ext = file_dot_sep[file_dot_sep.length-1];\n\n  \tnew_filename = filename.substr(0,filename.lastIndexOf(\".vcf\")) + \".sorted.vcf\";\n  \treturn '&& bgzip -c -f ' + new_filename + ' > ' + new_filename + '.gz'\n      \n  }\n  \n  \n  \n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            },
            "position": 100
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  filepath = $job.inputs.input_file.path\n\n  filename = filepath.split(\"/\").pop();\n\n  file_dot_sep = filename.split(\".\");\n  file_ext = file_dot_sep[file_dot_sep.length-1];\n\n  new_filename = filename.substr(0,filename.lastIndexOf(\".vcf\")) + \".sorted.vcf\";\n  \n  return '> '+new_filename;\n  \n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            },
            "position": 50
          }
        ],
        "sbg:revisionsInfo": [
          {
            "sbg:revisionNotes": null,
            "sbg:modifiedBy": "sevenbridges",
            "sbg:modifiedOn": 1453798863,
            "sbg:revision": 0
          },
          {
            "sbg:revisionNotes": null,
            "sbg:modifiedBy": "sevenbridges",
            "sbg:modifiedOn": 1453798864,
            "sbg:revision": 1
          },
          {
            "sbg:revisionNotes": null,
            "sbg:modifiedBy": "sevenbridges",
            "sbg:modifiedOn": 1453798865,
            "sbg:revision": 2
          },
          {
            "sbg:revisionNotes": "Changed memory, CPU and added parallel",
            "sbg:modifiedBy": "admin",
            "sbg:modifiedOn": 1473263742,
            "sbg:revision": 3
          },
          {
            "sbg:revisionNotes": "Compressable output",
            "sbg:modifiedBy": "admin",
            "sbg:modifiedOn": 1476270166,
            "sbg:revision": 4
          },
          {
            "sbg:revisionNotes": "Changed --parallel to -p",
            "sbg:modifiedBy": "admin",
            "sbg:modifiedOn": 1478009116,
            "sbg:revision": 5
          }
        ],
        "sbg:categories": [
          "VCF-Processing"
        ],
        "hints": [
          {
            "class": "DockerRequirement",
            "dockerPull": "images.sbgenomics.com/ognjenm/vcftools:0.1.14",
            "dockerImageId": "54cb823ba25a"
          },
          {
            "class": "sbg:CPURequirement",
            "value": {
              "script": "{\n  \n  return $job.inputs.parallel\n  \n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          },
          {
            "class": "sbg:MemRequirement",
            "value": {
              "script": "{\n  if ($job.inputs.mem_mb) {\n    \n    return $job.inputs.mem_mb\n    \n   }  else {\n      \n      return 1000\n      \n      }\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          }
        ],
        "sbg:contributors": [
          "sevenbridges",
          "admin"
        ],
        "label": "VCFtools Sort",
        "sbg:license": "GNU General Public License version 3.0 (GPLv3)",
        "sbg:validationErrors": [],
        "sbg:links": [
          {
            "id": "https://vcftools.github.io",
            "label": "Homepage"
          },
          {
            "id": "https://github.com/vcftools/vcftools",
            "label": "Source code"
          },
          {
            "id": "http://bioinformatics.oxfordjournals.org/content/27/15/2156",
            "label": "Publications"
          }
        ],
        "sbg:job": {
          "allocatedResources": {
            "mem": 100,
            "cpu": 2
          },
          "inputs": {
            "input_file": {
              "path": "sample1.vcf"
            },
            "compressed": true,
            "mem_mb": 100,
            "parallel": 2
          }
        },
        "appUrl": "/public/apps/#tool/admin/sbg-public-data/vcftools-sort-0-1-14/5",
        "description": "VCFtools sort sorts a VCF file.",
        "stdout": "",
        "sbg:toolkit": "VCFtools",
        "sbg:toolkitVersion": "0.1.14",
        "sbg:revisionNotes": "Changed --parallel to -p",
        "sbg:revision": 5,
        "sbg:id": "admin/sbg-public-data/vcftools-sort-0-1-14/5",
        "sbg:modifiedOn": 1478009116,
        "requirements": [
          {
            "requirements": [
              {
                "class": "DockerRequirement",
                "dockerPull": "rabix/js-engine"
              }
            ],
            "id": "#cwl-js-engine",
            "class": "ExpressionEngineRequirement",
            "engineCommand": "cwl-engine.js"
          }
        ],
        "class": "CommandLineTool",
        "sbg:sbgMaintained": false,
        "x": 504.70595415900743,
        "y": 309.90198471966914,
        "cwlVersion": "sbg:draft-2",
        "sbg:image_url": null,
        "inputs": [
          {
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "-p",
              "position": 2
            },
            "sbg:category": "Execution",
            "sbg:toolDefaultValue": "1",
            "description": "Change the number of sorts run concurrently to <int>.",
            "required": false,
            "id": "#parallel",
            "type": [
              "null",
              "int"
            ],
            "label": "Parallel threads"
          },
          {
            "sbg:stageInput": null,
            "sbg:category": "Execution",
            "sbg:toolDefaultValue": "N/A",
            "description": "Memory in MB for execution.",
            "required": false,
            "id": "#mem_mb",
            "type": [
              "null",
              "int"
            ],
            "label": "Memory in MB"
          },
          {
            "inputBinding": {
              "separate": false,
              "sbg:cmdInclude": true,
              "position": 1
            },
            "description": "Input file (vcf or vcf.gz)",
            "required": true,
            "id": "#input_file",
            "sbg:fileTypes": "VCF, VCF.GZ",
            "type": [
              "File"
            ],
            "label": "Input file"
          },
          {
            "sbg:stageInput": null,
            "sbg:category": "Execution",
            "sbg:toolDefaultValue": "FALSE",
            "description": "Check to make the output compressed (usually for further processing).",
            "required": false,
            "id": "#compressed",
            "type": [
              "null",
              "boolean"
            ],
            "label": "Compressed output"
          },
          {
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "-c"
            },
            "description": "Use natural ordering (1,2,10,MT,X) rather then the default (1,10,2,MT,X). This requires                                      new version of the unix \"sort\" command which supports the --version-sort option.",
            "required": false,
            "id": "#chromosomal_order",
            "type": [
              "null",
              "boolean"
            ],
            "label": "Chromosomal order"
          }
        ],
        "sbg:modifiedBy": "admin",
        "successCodes": [],
        "baseCommand": [
          "vcf-sort"
        ]
      },
      "inputs": [
        {
          "id": "#VCFtools_Sort.parallel"
        },
        {
          "id": "#VCFtools_Sort.mem_mb"
        },
        {
          "id": "#VCFtools_Sort.input_file",
          "source": [
            "#SBG_VCF_reheader.reheaded_vcf"
          ]
        },
        {
          "id": "#VCFtools_Sort.compressed"
        },
        {
          "default": true,
          "id": "#VCFtools_Sort.chromosomal_order"
        }
      ]
    },
    {
      "sbg:x": -156.4705757472826,
      "outputs": [
        {
          "id": "#VCFtools_Keep_SNPs_or_Indels.output_file"
        }
      ],
      "id": "#VCFtools_Keep_SNPs_or_Indels",
      "sbg:y": 309.9020253057065,
      "scatter": "#VCFtools_Keep_SNPs_or_Indels.input_file",
      "run": {
        "sbg:cmdPreview": "vcftools --vcf /path/to/input_file.ext  --keep-only-indels  --recode --recode-INFO-all --out input_file.Indels_only",
        "sbg:createdOn": 1472139853,
        "sbg:createdBy": "bogdang",
        "stdin": "",
        "sbg:toolAuthor": "Adam Auton, Petr Danecek, Anthony Marcketta",
        "outputs": [
          {
            "outputBinding": {
              "sbg:inheritMetadataFrom": "#input_file",
              "glob": {
                "script": "{\n  var input_file_path = [].concat($job.inputs.input_file)[0].path\n  var input_file_name = input_file_path.replace(/^.*[\\\\\\/]/, '').split('.')\n  var basename = input_file_name.slice(0, -1).join('.')\n  if ($job.inputs.variants_to_keep == 'SNP')\n  {\n    ext =  '.SNPs_only'\n  }\n  else\n  {\n    ext = '.Indels_only'\n  }\n  return basename + ext + '.recode.vcf'\n}",
                "class": "Expression",
                "engine": "#cwl-js-engine"
              },
              "secondaryFiles": [
                "*.idx"
              ]
            },
            "description": "VCF file containing only required type of variants.",
            "id": "#output_file",
            "sbg:fileTypes": "VCF",
            "type": [
              "null",
              "File"
            ],
            "label": "Output VCF"
          }
        ],
        "temporaryFailCodes": [],
        "id": "bix-demo/vcftools-0-1-14-demo/vcftools-keep-snps-or-indels/2",
        "sbg:latestRevision": 2,
        "sbg:projectName": "VCFtools 0.1.14 - Demo",
        "sbg:project": "bix-demo/vcftools-0-1-14-demo",
        "sbg:appVersion": [
          "sbg:draft-2"
        ],
        "arguments": [
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  if ($job.inputs.variants_to_keep == 'SNP')\n  {\n    return '--remove-indels'\n  }\n  else\n  {\n    return '--keep-only-indels'\n  }\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            },
            "position": 12
          },
          {
            "separate": true,
            "valueFrom": "--recode --recode-INFO-all",
            "position": 15
          },
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  var input_file_path = [].concat($job.inputs.input_file)[0].path\n  var input_file_name = input_file_path.replace(/^.*[\\\\\\/]/, '').split('.')\n  var basename = input_file_name.slice(0, -1).join('.')\n  if ($job.inputs.variants_to_keep == 'SNP')\n  {\n    ext =  '.SNPs_only'\n  }\n  else\n  {\n    ext = '.Indels_only'\n  }\n  return basename + ext\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            },
            "prefix": "--out",
            "position": 18
          }
        ],
        "sbg:revisionsInfo": [
          {
            "sbg:revisionNotes": null,
            "sbg:modifiedBy": "bogdang",
            "sbg:modifiedOn": 1472139853,
            "sbg:revision": 0
          },
          {
            "sbg:revisionNotes": null,
            "sbg:modifiedBy": "bogdang",
            "sbg:modifiedOn": 1472139865,
            "sbg:revision": 1
          },
          {
            "sbg:revisionNotes": "Removed index file",
            "sbg:modifiedBy": "ognjenm",
            "sbg:modifiedOn": 1473168292,
            "sbg:revision": 2
          }
        ],
        "sbg:categories": [
          "VCF-Processing"
        ],
        "hints": [
          {
            "class": "DockerRequirement",
            "dockerPull": "images.sbgenomics.com/thedzo/vcftools:0.1.14",
            "dockerImageId": "54cb823ba25a"
          },
          {
            "class": "sbg:CPURequirement",
            "value": 1
          },
          {
            "class": "sbg:MemRequirement",
            "value": 1000
          }
        ],
        "sbg:contributors": [
          "ognjenm",
          "bogdang"
        ],
        "label": "VCFtools Keep SNPs or Indels",
        "sbg:license": "GNU General Public License version 3.0 (GPLv3)",
        "sbg:validationErrors": [],
        "sbg:links": [
          {
            "id": "https://vcftools.github.io",
            "label": "Homepage"
          }
        ],
        "sbg:job": {
          "allocatedResources": {
            "mem": 1000,
            "cpu": 1
          },
          "inputs": {
            "variants_to_keep": "INDEL",
            "input_file": {
              "path": "/path/to/input_file.ext",
              "size": 0,
              "secondaryFiles": [
                {
                  "path": ".idx"
                }
              ],
              "class": "File"
            }
          }
        },
        "appUrl": "/u/bix-demo/vcftools-0-1-14-demo/apps/#bix-demo/vcftools-0-1-14-demo/vcftools-keep-snps-or-indels/2",
        "description": "VCFtools Keep SNPs or Indels outputs VCF file containing only SNPs or only Indels in input VCF file.",
        "stdout": "",
        "sbg:toolkit": "VCFtools",
        "sbg:toolkitVersion": "0.1.14",
        "sbg:revisionNotes": "Removed index file",
        "sbg:revision": 2,
        "sbg:id": "bix-demo/vcftools-0-1-14-demo/vcftools-keep-snps-or-indels/2",
        "sbg:modifiedOn": 1473168292,
        "requirements": [
          {
            "requirements": [
              {
                "class": "DockerRequirement",
                "dockerPull": "rabix/js-engine"
              }
            ],
            "id": "#cwl-js-engine",
            "class": "ExpressionEngineRequirement",
            "engineCommand": "cwl-engine.js"
          }
        ],
        "class": "CommandLineTool",
        "sbg:sbgMaintained": false,
        "x": -156.4705757472826,
        "y": 309.9020253057065,
        "cwlVersion": "sbg:draft-2",
        "sbg:image_url": null,
        "inputs": [
          {
            "sbg:stageInput": null,
            "sbg:category": "Input",
            "description": "Choose if the output file should contain only SNPs or only Indels from original file.",
            "required": true,
            "id": "#variants_to_keep",
            "type": [
              {
                "type": "enum",
                "name": "variants_to_keep",
                "symbols": [
                  "SNP",
                  "INDEL"
                ]
              }
            ],
            "label": "Keep SNPs or indels?"
          },
          {
            "inputBinding": {
              "separate": true,
              "itemSeparator": " ",
              "sbg:cmdInclude": true,
              "prefix": "--vcf",
              "position": 10
            },
            "description": "Input file.",
            "required": true,
            "id": "#input_file",
            "sbg:fileTypes": "VCF",
            "type": [
              "File"
            ],
            "label": "Input files"
          }
        ],
        "sbg:modifiedBy": "ognjenm",
        "successCodes": [],
        "baseCommand": [
          "vcftools"
        ]
      },
      "inputs": [
        {
          "default": "SNP",
          "id": "#VCFtools_Keep_SNPs_or_Indels.variants_to_keep"
        },
        {
          "id": "#VCFtools_Keep_SNPs_or_Indels.input_file",
          "source": [
            "#input_files"
          ]
        }
      ]
    },
    {
      "sbg:x": 1821.255737304688,
      "outputs": [
        {
          "id": "#Fishplot_0_3.plotting_log"
        },
        {
          "id": "#Fishplot_0_3.fishplot_plots"
        }
      ],
      "id": "#Fishplot_0_3",
      "sbg:y": 346.69610595703136,
      "run": {
        "sbg:cmdPreview": "Rscript --vanilla Fishplot.R  > plotting.log",
        "sbg:createdOn": 1472570110,
        "sbg:createdBy": "uros_sipetic",
        "stdin": "",
        "sbg:toolAuthor": "Christopher A. Miller, Joshua McMichael, Ha X. Dang, Christopher A. Maher, Li Ding, Timothy J . Ley, Elaine R. Mardis, Richard K. Wilson",
        "outputs": [
          {
            "outputBinding": {
              "sbg:inheritMetadataFrom": "#input_file",
              "glob": "plotting.log"
            },
            "description": "Log file to catch errors in case no output is made.",
            "id": "#plotting_log",
            "sbg:fileTypes": "LOG",
            "type": [
              "null",
              "File"
            ],
            "label": "Plotting Log"
          },
          {
            "outputBinding": {
              "sbg:inheritMetadataFrom": "#input_file",
              "glob": "*.pdf"
            },
            "description": "PDF file produced by the Fishplot tool.",
            "id": "#fishplot_plots",
            "sbg:fileTypes": "PDF",
            "type": [
              "null",
              "File"
            ],
            "label": "Fishplot output"
          }
        ],
        "temporaryFailCodes": [],
        "id": "uros_sipetic/fishplot-0-3/fishplot-0-3/22",
        "sbg:latestRevision": 22,
        "sbg:projectName": "Fishplot 0.3 - Demo",
        "sbg:project": "uros_sipetic/fishplot-0-3",
        "sbg:appVersion": [
          "sbg:draft-2"
        ],
        "arguments": [],
        "sbg:revisionsInfo": [
          {
            "sbg:revisionNotes": null,
            "sbg:modifiedBy": "uros_sipetic",
            "sbg:modifiedOn": 1472570110,
            "sbg:revision": 0
          },
          {
            "sbg:revisionNotes": null,
            "sbg:modifiedBy": "uros_sipetic",
            "sbg:modifiedOn": 1472571962,
            "sbg:revision": 1
          },
          {
            "sbg:revisionNotes": null,
            "sbg:modifiedBy": "uros_sipetic",
            "sbg:modifiedOn": 1472573615,
            "sbg:revision": 2
          },
          {
            "sbg:revisionNotes": null,
            "sbg:modifiedBy": "uros_sipetic",
            "sbg:modifiedOn": 1472577240,
            "sbg:revision": 3
          },
          {
            "sbg:revisionNotes": null,
            "sbg:modifiedBy": "uros_sipetic",
            "sbg:modifiedOn": 1472577466,
            "sbg:revision": 4
          },
          {
            "sbg:revisionNotes": null,
            "sbg:modifiedBy": "uros_sipetic",
            "sbg:modifiedOn": 1472577557,
            "sbg:revision": 5
          },
          {
            "sbg:revisionNotes": null,
            "sbg:modifiedBy": "uros_sipetic",
            "sbg:modifiedOn": 1472577836,
            "sbg:revision": 6
          },
          {
            "sbg:revisionNotes": null,
            "sbg:modifiedBy": "uros_sipetic",
            "sbg:modifiedOn": 1472578136,
            "sbg:revision": 7
          },
          {
            "sbg:revisionNotes": null,
            "sbg:modifiedBy": "uros_sipetic",
            "sbg:modifiedOn": 1472634711,
            "sbg:revision": 8
          },
          {
            "sbg:revisionNotes": null,
            "sbg:modifiedBy": "uros_sipetic",
            "sbg:modifiedOn": 1472637454,
            "sbg:revision": 9
          },
          {
            "sbg:revisionNotes": null,
            "sbg:modifiedBy": "uros_sipetic",
            "sbg:modifiedOn": 1472637640,
            "sbg:revision": 10
          },
          {
            "sbg:revisionNotes": null,
            "sbg:modifiedBy": "uros_sipetic",
            "sbg:modifiedOn": 1472639720,
            "sbg:revision": 11
          },
          {
            "sbg:revisionNotes": null,
            "sbg:modifiedBy": "uros_sipetic",
            "sbg:modifiedOn": 1472640669,
            "sbg:revision": 12
          },
          {
            "sbg:revisionNotes": null,
            "sbg:modifiedBy": "uros_sipetic",
            "sbg:modifiedOn": 1472645237,
            "sbg:revision": 13
          },
          {
            "sbg:revisionNotes": null,
            "sbg:modifiedBy": "uros_sipetic",
            "sbg:modifiedOn": 1472647269,
            "sbg:revision": 14
          },
          {
            "sbg:revisionNotes": null,
            "sbg:modifiedBy": "uros_sipetic",
            "sbg:modifiedOn": 1473264486,
            "sbg:revision": 15
          },
          {
            "sbg:revisionNotes": "error handling from ClonEvol",
            "sbg:modifiedBy": "dusan_randjelovic",
            "sbg:modifiedOn": 1478942195,
            "sbg:revision": 16
          },
          {
            "sbg:revisionNotes": "Error handling, escape from fn",
            "sbg:modifiedBy": "dusan_randjelovic",
            "sbg:modifiedOn": 1478952720,
            "sbg:revision": 17
          },
          {
            "sbg:revisionNotes": "Added output log to collect stdout",
            "sbg:modifiedBy": "dusan_randjelovic",
            "sbg:modifiedOn": 1478953383,
            "sbg:revision": 18
          },
          {
            "sbg:revisionNotes": null,
            "sbg:modifiedBy": "uros_sipetic",
            "sbg:modifiedOn": 1479810236,
            "sbg:revision": 19
          },
          {
            "sbg:revisionNotes": null,
            "sbg:modifiedBy": "uros_sipetic",
            "sbg:modifiedOn": 1479837659,
            "sbg:revision": 20
          },
          {
            "sbg:revisionNotes": null,
            "sbg:modifiedBy": "uros_sipetic",
            "sbg:modifiedOn": 1493228230,
            "sbg:revision": 21
          },
          {
            "sbg:revisionNotes": null,
            "sbg:modifiedBy": "uros_sipetic",
            "sbg:modifiedOn": 1493287459,
            "sbg:revision": 22
          }
        ],
        "sbg:categories": [
          "Tumor-heterogeneity",
          "Sub-clonality"
        ],
        "hints": [
          {
            "class": "sbg:CPURequirement",
            "value": 1
          },
          {
            "class": "sbg:MemRequirement",
            "value": 1000
          },
          {
            "class": "DockerRequirement",
            "dockerPull": "images.sbgenomics.com/uros_sipetic/fishplot:0.3",
            "dockerImageId": ""
          }
        ],
        "sbg:contributors": [
          "uros_sipetic",
          "dusan_randjelovic"
        ],
        "label": "Fishplot 0.3",
        "sbg:license": "Apache License 2.0",
        "sbg:validationErrors": [],
        "sbg:links": [
          {
            "id": "https://github.com/chrisamiller/fishplot",
            "label": "Homepage"
          },
          {
            "id": "https://github.com/chrisamiller/fishplot",
            "label": "Source Code"
          },
          {
            "id": "https://github.com/chrisamiller/fishplot/archive/v0.3.tar.gz",
            "label": "Download"
          },
          {
            "id": "http://biorxiv.org/content/biorxiv/early/2016/06/15/059055.full.pdf",
            "label": "Publication"
          },
          {
            "id": "https://github.com/chrisamiller/fishplot/tree/master/man",
            "label": "Documentation"
          }
        ],
        "description": "Massively parallel sequencing at depth is now enabling tumor heterogeneity and evolution to be characterized in unprecedented detail. Tracking these changes in clonal architecture often provides insight into therapeutic response and resistance. Easily interpretable data visualizations can greatly aid these  studies, especially in cases with multiple timepoints. Current data visualization methods are typically manual and laborious, and often only approximate subclonal fractions. \n\nFishplot is an R package that accurately and intuitively displays changes in clonal structure over time. It requires simple input data and produces illustrative and easy-to-interpret graphs suitable for diagnosis, presentation, and publication.\n\n### Common Issues ###\nCurrently, Fishplot works well using ClonEvol model output as an input file.",
        "stdout": "plotting.log",
        "sbg:toolkit": "Fishplot",
        "sbg:toolkitVersion": "0.3",
        "sbg:revision": 22,
        "sbg:id": "uros_sipetic/fishplot-0-3/fishplot-0-3/22",
        "sbg:modifiedOn": 1493287459,
        "requirements": [
          {
            "class": "CreateFileRequirement",
            "fileDef": [
              {
                "filename": "Fishplot.R",
                "fileContent": {
                  "script": "{\n  var COMMAND = \"library(fishplot)\\n\"\n  var z = \"library(clonevol)\\n\"\n  COMMAND += z\n  \n  //generate phylogeny with clonevol\n  tmp1 = $job.inputs.input_file\n  tmp2 = tmp1.path.split('/').pop()\n  z = \"fishplot <- function(){\\n\\n\\\nload('\" + tmp2 + \"')\\n\\n\"\n  COMMAND += z\n  \n  // catch exceptions from ClonEvol\n  null_models = 'if (is.null(x$matched$index)){\\n\\\n  return(\"NULL models\")\\n\\\n}\\n'\n  COMMAND += null_models\n\n  no_subclones = 'subclones_per_sample <- sapply(x$models, function(samp) nrow(samp[[1]]))\\n\\\nif (1 %in% subclones_per_sample){\\n\\\n  no_subclones <- grepl(1, subclones_per_sample)\\n\\\n  return(paste0(\"NO subclones in samples: \", names(subclones_per_sample[no_subclones])))\\n\\\n}\\n\\n'\n  COMMAND += no_subclones\n  \n  //create a list of fish objects \n  z = \"f = generateFishplotInputs(results=x)\\n\"\n  z += \"fishes = createFishPlotObjects(f)\\n\"\n  COMMAND +=z\n  \n  //plot with fishplot\n  tmp3 = tmp2.split('.')\n  tmp4 = tmp3[0]\n  z = \"pdf('\" + tmp4 + \".fish.pdf', width=8, height=5)\\n\"\n  z += \"for (i in 1:length(fishes)){\\n\\\n\tfish = layoutClones(fishes[[i]])\\n\\\n\tfish = setCol(fish,f$clonevol.clone.colors)\\n\"\n  COMMAND += z\n  \n  z = \"\\tfishPlot(fish,\\n\\\n\tvlines=seq(1, length(s1)),\\n\\\n\tvlab=s1\"\n    \n  if ($job.inputs.shape) {\n    x = $job.inputs.shape\n    z += \",\\n\\\n\tshape='\" + x + \"'\"\n  } else {\n    z += \",\\n\\\n\tshape='spline'\"\n  }\n  \n  if ($job.inputs.title_btm) {\n    x = $job.inputs.title_btm\n    z += \",\\n\\\n\ttitle.btm='\" + x + \"'\"\n  } else {\n    z += \",\\n\\\n\ttitle.btm='\" + tmp4 + \"'\"\n  }\n\n  if ($job.inputs.cex_title) {\n    x = $job.inputs.cex_title\n    z += \",\\n\\\n\tcex.title=\" + x\n  } else {\n    z += \",\\n\\\n\tcex.title=0.5\"\n  }\n  \n  if ($job.inputs.pad_left) {\n    x = $job.inputs.pad_left\n    z += \",\\n\\\n\tpad.left=\" + x\n  } else {\n    z += \",\\n\\\n\tpad.left=0.5\"\n  }\n  \n  if ($job.inputs.col_vline) {\n    x = $job.inputs.col_vline\n    z += \",\\n\\\n\tcol.vline='\" + x + \"'\"\n  } else {\n    z += \",\\n\\\n\tcol.vline='#FFFFFF99'\"\n  }\n  \n  if ($job.inputs.border) {\n    x = $job.inputs.border\n    z += \",\\n\\\n\tborder=\" + x\n  } else {\n    z += \",\\n\\\n\tborder=0.5\"\n  }\n  \n  if ($job.inputs.col_border) {\n    x = $job.inputs.col_border\n    z += \",\\n\\\n\tcol.border='\" + x + \"'\"\n  } else {\n    z += \",\\n\\\n\tcol.border='#777777'\"\n  }\n  \n  if ($job.inputs.ramp_angle) {\n    x = $job.inputs.ramp_angle\n    z += \",\\n\\\n\tramp.angle=\" + x\n  } else {\n    z += \",\\n\\\n\tramp.angle=0.5\"\n  }\n  \n  if ($job.inputs.title) {\n    x = $job.inputs.title\n    z += \",\\n\\\n\ttitle='\" + x + \"'\"\n  } else {\n    z += \",\\n\\\n\ttitle='Fishplot of \" + tmp4 + \"'\"\n  }\n  \n  if ($job.inputs.cex_vlab) {\n    x = $job.inputs.cex_vlab\n    z += \",\\n\\\n\tcex.vlab=\" + x\n  } else {\n    z += \",\\n\\\n\tcex.vlab=0.7\"\n  }\n  \n  z += \")\\n}\\n\"\n  z += \"dev.off()\\n\\\n}\\n\\\nfishplot()\"\n  COMMAND +=z\n  return COMMAND\n}",
                  "class": "Expression",
                  "engine": "#cwl-js-engine"
                }
              }
            ]
          },
          {
            "requirements": [
              {
                "class": "DockerRequirement",
                "dockerPull": "rabix/js-engine"
              }
            ],
            "id": "#cwl-js-engine",
            "class": "ExpressionEngineRequirement"
          }
        ],
        "class": "CommandLineTool",
        "sbg:sbgMaintained": false,
        "x": 1821.255737304688,
        "y": 346.69610595703136,
        "cwlVersion": "sbg:draft-2",
        "sbg:image_url": null,
        "inputs": [
          {
            "sbg:category": "Arguments",
            "sbg:toolDefaultValue": "NULL",
            "description": "A string for the title at the bottom left, internal to the plot.",
            "id": "#title_btm",
            "type": [
              "null",
              "string"
            ],
            "label": "Bottom title"
          },
          {
            "sbg:category": "Arguments",
            "sbg:toolDefaultValue": "NULL",
            "description": "A string for the title above the plot.",
            "id": "#title",
            "type": [
              "null",
              "string"
            ],
            "label": "Title"
          },
          {
            "sbg:stageInput": null,
            "sbg:category": "Arguments",
            "sbg:toolDefaultValue": "spline",
            "description": "The type of shape to construct the plot out of. The \"spline\" and \"polygon\" methods work well. \"Bezier\" is more hit or miss.",
            "id": "#shape",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "shape",
                "symbols": [
                  "spline",
                  "polygon",
                  "bezier"
                ]
              }
            ],
            "label": "Shape"
          },
          {
            "sbg:stageInput": null,
            "sbg:category": "Arguments",
            "sbg:toolDefaultValue": "0.5",
            "description": "{A numeric value between 0 and 1 that indicates how steeply the shape should expand from it's leftmost origin to the first measured point. Only used when shape=\"polygon\".",
            "id": "#ramp_angle",
            "type": [
              "null",
              "float"
            ],
            "label": "Ramp angle"
          },
          {
            "sbg:category": "Arguments",
            "sbg:toolDefaultValue": "0.5",
            "description": "The amount of \"ramp-up\" to the left of the first timepoint. Given as a fraction of the total plot width.",
            "id": "#pad_left",
            "type": [
              "null",
              "float"
            ],
            "label": "Left padding"
          },
          {
            "sbg:stageInput": "link",
            "sbg:category": "Arguments",
            "description": "RData file outputed by ClonEvol, containing an R object with the proper ClonEvol model, to be used for plotting by Fishplot.",
            "required": true,
            "id": "#input_file",
            "sbg:fileTypes": "RDATA",
            "type": [
              "File"
            ],
            "label": "ClonEvol RData file"
          },
          {
            "sbg:category": "Arguments",
            "sbg:toolDefaultValue": "#FFFFFF99",
            "description": "Color value for the vertical lines.",
            "id": "#col_vline",
            "type": [
              "null",
              "string"
            ],
            "label": "Vertical line color"
          },
          {
            "sbg:category": "Arguments",
            "sbg:toolDefaultValue": "#777777",
            "description": "A color for the border line.",
            "id": "#col_border",
            "type": [
              "null",
              "string"
            ],
            "label": "Border color"
          },
          {
            "sbg:stageInput": null,
            "sbg:category": "Arguments",
            "sbg:toolDefaultValue": "0.7",
            "description": "A numeric value for scaling the top label size.",
            "id": "#cex_vlab",
            "type": [
              "null",
              "float"
            ],
            "label": "Top lable size scaling"
          },
          {
            "sbg:category": "Arguments",
            "sbg:toolDefaultValue": "0.5",
            "description": "A numeric value for scaling the title size.",
            "id": "#cex_title",
            "type": [
              "null",
              "float"
            ],
            "label": "Title size scaling"
          },
          {
            "sbg:stageInput": null,
            "sbg:category": "Arguments",
            "sbg:toolDefaultValue": "0.5",
            "description": "A numeric width for the border line around this polygon.",
            "id": "#border",
            "type": [
              "null",
              "float"
            ],
            "label": "Border width"
          }
        ],
        "sbg:job": {
          "allocatedResources": {
            "mem": 1000,
            "cpu": 1
          },
          "inputs": {
            "col_border": "",
            "title": "",
            "border": null,
            "cex_title": null,
            "title_btm": "",
            "cex_vlab": null,
            "col_vline": "",
            "input_file": {
              "path": "/path/to/sample_name.sciclone.clusters.clonevol_for_fishplot.RData",
              "size": 0,
              "secondaryFiles": [],
              "class": "File"
            },
            "ramp_angle": null,
            "shape": "spline",
            "pad_left": null
          }
        },
        "sbg:modifiedBy": "uros_sipetic",
        "successCodes": [
          1,
          0
        ],
        "baseCommand": [
          "Rscript",
          "--vanilla",
          "Fishplot.R"
        ]
      },
      "inputs": [
        {
          "id": "#Fishplot_0_3.title_btm"
        },
        {
          "id": "#Fishplot_0_3.title"
        },
        {
          "id": "#Fishplot_0_3.shape"
        },
        {
          "id": "#Fishplot_0_3.ramp_angle"
        },
        {
          "id": "#Fishplot_0_3.pad_left"
        },
        {
          "id": "#Fishplot_0_3.input_file",
          "source": [
            "#ClonEvol_0_1.clonevol_model"
          ]
        },
        {
          "id": "#Fishplot_0_3.col_vline"
        },
        {
          "id": "#Fishplot_0_3.col_border"
        },
        {
          "id": "#Fishplot_0_3.cex_vlab"
        },
        {
          "id": "#Fishplot_0_3.cex_title"
        },
        {
          "id": "#Fishplot_0_3.border"
        }
      ]
    },
    {
      "sbg:x": 932.7647094726564,
      "outputs": [
        {
          "id": "#SBG_SciClone_VCF_parser.vafs"
        },
        {
          "id": "#SBG_SciClone_VCF_parser.regions_to_exclude"
        }
      ],
      "id": "#SBG_SciClone_VCF_parser",
      "sbg:y": 304.0196228027345,
      "run": {
        "sbg:license": "Apache License 2.0",
        "sbg:cmdPreview": "python vcf_parser.py --vcf /path/to/merged.vcf   && for f in ./*.vaf; do python regions_to_exclude.py -i $f -t 70; done",
        "sbg:createdOn": 1473845885,
        "sbg:createdBy": "uros_sipetic",
        "stdin": "",
        "sbg:toolAuthor": "Seven Bridges Genomics",
        "outputs": [
          {
            "outputBinding": {
              "glob": "*.vaf"
            },
            "description": "File appropriate to use for SciClone VAF input.",
            "id": "#vafs",
            "sbg:fileTypes": "VAF",
            "type": [
              "null",
              {
                "items": "File",
                "type": "array"
              }
            ],
            "label": "SciClone VAF file(s)"
          },
          {
            "outputBinding": {
              "sbg:inheritMetadataFrom": "#vcf",
              "glob": "*.exclude.txt"
            },
            "description": "Files with regions to exclude, one for each inut sample. These files contain lines with mutations that have VAFs higher than the specified threshold.",
            "id": "#regions_to_exclude",
            "sbg:fileTypes": "TXT",
            "type": [
              "null",
              {
                "items": "File",
                "type": "array"
              }
            ],
            "label": "Regions to exclude"
          }
        ],
        "sbg:contributors": [
          "uros_sipetic"
        ],
        "temporaryFailCodes": [],
        "id": "https://api.sbgenomics.com/v2/apps/uros_sipetic/sciclone-1-1-demo/sbg-sciclone-vcf-parser/22/raw/",
        "sbg:projectName": "SciClone 1.1 - Demo",
        "sbg:project": "uros_sipetic/sciclone-1-1-demo",
        "sbg:appVersion": [
          "sbg:draft-2"
        ],
        "arguments": [
          {
            "separate": true,
            "valueFrom": {
              "script": "{\n  if ($job.inputs.vaf_threshold) {\n  \tvar vaf_threshold = $job.inputs.vaf_threshold\n  } else {\n    var vaf_threshold = 70\n  }\n  return \" && for f in ./*.vaf; do python regions_to_exclude.py -i $f -t \" + vaf_threshold + \"; done\"\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            },
            "position": 99
          }
        ],
        "sbg:revisionsInfo": [
          {
            "sbg:revisionNotes": "Copy of uros_sipetic/sciclone-1-1/varscan2-vcf-parser-for-sciclone/11",
            "sbg:modifiedBy": "uros_sipetic",
            "sbg:modifiedOn": 1473845885,
            "sbg:revision": 0
          },
          {
            "sbg:revisionNotes": "Copy of uros_sipetic/sciclone-1-1/varscan2-vcf-parser-for-sciclone/12",
            "sbg:modifiedBy": "uros_sipetic",
            "sbg:modifiedOn": 1473848953,
            "sbg:revision": 1
          },
          {
            "sbg:revisionNotes": "Copy of uros_sipetic/sciclone-1-1/varscan2-vcf-parser-for-sciclone/13",
            "sbg:modifiedBy": "uros_sipetic",
            "sbg:modifiedOn": 1479838862,
            "sbg:revision": 2
          },
          {
            "sbg:revisionNotes": "Copy of uros_sipetic/sciclone-1-1/varscan2-vcf-parser-for-sciclone/14",
            "sbg:modifiedBy": "uros_sipetic",
            "sbg:modifiedOn": 1479995191,
            "sbg:revision": 3
          },
          {
            "sbg:revisionNotes": "Copy of uros_sipetic/sciclone-1-1/varscan2-vcf-parser-for-sciclone/15",
            "sbg:modifiedBy": "uros_sipetic",
            "sbg:modifiedOn": 1481650835,
            "sbg:revision": 4
          },
          {
            "sbg:revisionNotes": "Copy of uros_sipetic/sciclone-1-1/varscan2-vcf-parser-for-sciclone/18",
            "sbg:modifiedBy": "uros_sipetic",
            "sbg:modifiedOn": 1485195596,
            "sbg:revision": 5
          },
          {
            "sbg:revisionNotes": "Copy of uros_sipetic/sciclone-1-1/varscan2-vcf-parser-for-sciclone/18",
            "sbg:modifiedBy": "uros_sipetic",
            "sbg:modifiedOn": 1485195728,
            "sbg:revision": 6
          },
          {
            "sbg:revisionNotes": "Copy of uros_sipetic/sciclone-1-1/varscan2-vcf-parser-for-sciclone/19",
            "sbg:modifiedBy": "uros_sipetic",
            "sbg:modifiedOn": 1485197412,
            "sbg:revision": 7
          },
          {
            "sbg:revisionNotes": "Copy of uros_sipetic/sciclone-1-1/varscan2-vcf-parser-for-sciclone/20",
            "sbg:modifiedBy": "uros_sipetic",
            "sbg:modifiedOn": 1485253335,
            "sbg:revision": 8
          },
          {
            "sbg:revisionNotes": "Copy of uros_sipetic/sciclone-1-1/varscan2-vcf-parser-for-sciclone/21",
            "sbg:modifiedBy": "uros_sipetic",
            "sbg:modifiedOn": 1485273453,
            "sbg:revision": 9
          },
          {
            "sbg:revisionNotes": "Copy of uros_sipetic/sciclone-1-1/varscan2-vcf-parser-for-sciclone/22",
            "sbg:modifiedBy": "uros_sipetic",
            "sbg:modifiedOn": 1485276229,
            "sbg:revision": 10
          },
          {
            "sbg:revisionNotes": "Copy of uros_sipetic/sciclone-1-1/varscan2-vcf-parser-for-sciclone/23",
            "sbg:modifiedBy": "uros_sipetic",
            "sbg:modifiedOn": 1485294211,
            "sbg:revision": 11
          },
          {
            "sbg:revisionNotes": "Copy of uros_sipetic/sciclone-1-1/varscan2-vcf-parser-for-sciclone/24",
            "sbg:modifiedBy": "uros_sipetic",
            "sbg:modifiedOn": 1485298366,
            "sbg:revision": 12
          },
          {
            "sbg:revisionNotes": "Copy of uros_sipetic/sciclone-1-1/varscan2-vcf-parser-for-sciclone/25",
            "sbg:modifiedBy": "uros_sipetic",
            "sbg:modifiedOn": 1485342234,
            "sbg:revision": 13
          },
          {
            "sbg:revisionNotes": "Copy of uros_sipetic/sciclone-1-1/varscan2-vcf-parser-for-sciclone/26",
            "sbg:modifiedBy": "uros_sipetic",
            "sbg:modifiedOn": 1485351122,
            "sbg:revision": 14
          },
          {
            "sbg:revisionNotes": "Copy of uros_sipetic/sciclone-1-1/varscan2-vcf-parser-for-sciclone/27",
            "sbg:modifiedBy": "uros_sipetic",
            "sbg:modifiedOn": 1485361732,
            "sbg:revision": 15
          },
          {
            "sbg:revisionNotes": "Copy of uros_sipetic/sciclone-1-1/varscan2-vcf-parser-for-sciclone/28",
            "sbg:modifiedBy": "uros_sipetic",
            "sbg:modifiedOn": 1485947551,
            "sbg:revision": 16
          },
          {
            "sbg:revisionNotes": "Copy of uros_sipetic/sciclone-1-1/varscan2-vcf-parser-for-sciclone/29",
            "sbg:modifiedBy": "uros_sipetic",
            "sbg:modifiedOn": 1485960585,
            "sbg:revision": 17
          },
          {
            "sbg:revisionNotes": "Copy of uros_sipetic/sciclone-1-1/varscan2-vcf-parser-for-sciclone/30",
            "sbg:modifiedBy": "uros_sipetic",
            "sbg:modifiedOn": 1491832150,
            "sbg:revision": 18
          },
          {
            "sbg:revisionNotes": "Copy of uros_sipetic/sciclone-1-1/varscan2-vcf-parser-for-sciclone/31",
            "sbg:modifiedBy": "uros_sipetic",
            "sbg:modifiedOn": 1494348639,
            "sbg:revision": 19
          },
          {
            "sbg:revisionNotes": "Copy of uros_sipetic/sciclone-1-1/varscan2-vcf-parser-for-sciclone/32",
            "sbg:modifiedBy": "uros_sipetic",
            "sbg:modifiedOn": 1494435578,
            "sbg:revision": 20
          },
          {
            "sbg:revisionNotes": "Copy of uros_sipetic/sciclone-1-1/varscan2-vcf-parser-for-sciclone/33",
            "sbg:modifiedBy": "uros_sipetic",
            "sbg:modifiedOn": 1494437295,
            "sbg:revision": 21
          },
          {
            "sbg:revisionNotes": "Copy of uros_sipetic/sciclone-1-1/varscan2-vcf-parser-for-sciclone/34",
            "sbg:modifiedBy": "uros_sipetic",
            "sbg:modifiedOn": 1494516132,
            "sbg:revision": 22
          }
        ],
        "sbg:categories": [
          "Other"
        ],
        "hints": [
          {
            "class": "sbg:CPURequirement",
            "value": 1
          },
          {
            "class": "sbg:MemRequirement",
            "value": 1000
          },
          {
            "class": "DockerRequirement",
            "dockerPull": "images.sbgenomics.com/dusan_randjelovic/sci-python:2.7",
            "dockerImageId": ""
          }
        ],
        "sbg:modifiedOn": 1494516132,
        "label": "SBG SciClone VCF parser",
        "class": "CommandLineTool",
        "sbg:validationErrors": [],
        "sbg:job": {
          "allocatedResources": {
            "mem": 1000,
            "cpu": 1
          },
          "inputs": {
            "vaf_threshold": null,
            "vcf": {
              "path": "/path/to/merged.vcf",
              "size": 0,
              "secondaryFiles": [],
              "class": "File"
            },
            "bams": [
              {
                "path": "/path/to/tumor-1.bam",
                "size": 0,
                "secondaryFiles": [],
                "class": "File"
              },
              {
                "path": "/path/to/tumor-2.bam",
                "size": 0,
                "secondaryFiles": [],
                "class": "File"
              }
            ]
          }
        },
        "description": "This tool parses a VCF file, containing calls for one or more samples, into the appropriate VAF files suitable for input to SciClone. It also outputs files with regions to exclude from SciClone analysis, most notably lines with VAFs higher than a certain threshold. \n\n### Common Issues ###\n1. In order for the tool to function properly for multiple samples, names of the samples in the VCF must be contained in the respective BAM file names. Otherwise, if there is just one input VCF file, the BAM input is not required.\n2. The VCF formats from the following variant callers are currently supported:\nMuSE\nTNHaplotyper\nMuTect2\nVarScan2\nVarDict\nStrelka",
        "stdout": "",
        "sbg:toolkit": "SBGTools",
        "sbg:toolkitVersion": "v1.0",
        "sbg:revisionNotes": "Copy of uros_sipetic/sciclone-1-1/varscan2-vcf-parser-for-sciclone/34",
        "sbg:revision": 22,
        "sbg:id": "uros_sipetic/sciclone-1-1-demo/sbg-sciclone-vcf-parser/22",
        "sbg:copyOf": "uros_sipetic/sciclone-1-1/varscan2-vcf-parser-for-sciclone/34",
        "requirements": [
          {
            "class": "CreateFileRequirement",
            "fileDef": [
              {
                "filename": "vcf_parser.py",
                "fileContent": "\"\"\"\nA script that performs conversion of a standard VCF to a variant allele frequency (VAF) file, as required by SciClone.\n\"\"\"\nimport sys\nimport argparse\nimport vcf\nimport pysam\n\n\ndef parse_tnhap_mutect_rec(rec):\n    \"\"\"\n    Parses a VCF sample record written by TNHaplotyper or MuTect.\n    :param rec: A PyVCF sample record.\n    :return: (VAF, (ref_allele_dept, alt_allele_depth))\n    \"\"\"\n    depths = rec['AD']\n    ref_depth = depths[0]\n    alt_depth = sum(depths[1:])\n    if (ref_depth + alt_depth) != 0:\n        vaf = float(alt_depth) / (ref_depth + alt_depth) * 100\n    else:\n        vaf = 0\n    if vaf==0:\n        vaf = rec['AF']*100\n    return vaf, (ref_depth, alt_depth)\n\ndef parse_haplotypers_rec(rec):\n    \"\"\"\n    Parses a VCF sample record written by GATK or Sentieon haplotype callers.\n    :param rec: A PyVCF sample record.\n    :return: (VAF, (ref_allele_dept, alt_allele_depth))\n    \"\"\"\n    depths = rec['AD']\n    ref_depth = depths[0]\n    alt_depth = sum(depths[1:])\n    if (ref_depth + alt_depth) != 0:\n        vaf = float(alt_depth) / (ref_depth + alt_depth) * 100\n    else:\n        vaf = 0\n    return vaf, (ref_depth, alt_depth)\n\ndef parse_muse_rec(rec):\n    \"\"\"\n    Parses a VCF sample record written by MuSE.\n    :param rec: A PyVCF sample record.\n    :return: (VAF, (ref_allele_dept, alt_allele_depth))\n    \"\"\"\n    depths = rec['AD']\n    ref_depth = depths[0]\n    alt_depth = sum(depths[1:])\n    if (ref_depth + alt_depth) != 0:\n        vaf = float(alt_depth) / (ref_depth + alt_depth) * 100\n    else:\n        vaf = 0\n    return vaf, (ref_depth, alt_depth)\n\ndef parse_varscan_rec(rec):\n    \"\"\"\n    Parses a VCF sample record written by VarScan.\n    :param rec: A PyVCF sample record.\n    :return: (VAF, (ref_allele_dept, alt_allele_depth))\n    \"\"\"\n    return float(rec['FREQ'][:-1]), (rec['RD'], rec['AD'])\n\n\ndef parse_vardict_rec(rec):\n    \"\"\"\n    Parses a VCF sample record written by VarDict.\n    :param rec: A PyVCF sample record.\n    :return: (VAF, (ref_allele_dept, alt_allele_depth))\n    \"\"\"\n    return rec['AF'] * 100, (rec['DP'] - rec['VD'], rec['VD'])\n\n    \ndef parse_strelka_rec(rec,ref,alt):\n    \"\"\"\n    Parses a VCF sample record written by Strelka.\n    :param rec: A PyVCF sample record.\n    :return: (VAF, (ref_allele_dept, alt_allele_depth))\n    \"\"\"\n    REF_depth = rec[str(ref)+'U'][1]\n    ALT_depth = 0\n    for base in alt:\n        ALT_depth += rec[str(base)+'U'][1]\n    if (float(ALT_depth)+float(REF_depth)) != 0:\n        VAF = float(ALT_depth)/(float(ALT_depth)+float(REF_depth))\n    else:\n        VAF = 0\n    return VAF*100, (REF_depth,ALT_depth)  \n    \n    \ndef sniff_out_caller(rec):\n    \"\"\"\n    Tries to guess the caller that made a record.\n    :param rec: A PyVCF sample record.\n    :raise ValueError: If the caller's identity could not be inferred.\n    :return: The name of the caller.\n    \"\"\"\n    format_recs = rec.data.__dict__\n    if 'ALT_F1R2' in format_recs:\n        return 'TNHaplotyper'\n    elif 'DP4' in format_recs:\n        return 'VarScan'\n    elif 'ADJAF' in format_recs:\n        return 'VarDict'\n    elif 'SS' in format_recs and 'BQ' in format_recs and 'FA' in format_recs:\n        return 'MuTect'\n    elif 'SS' in format_recs and 'BQ' in format_recs:\n        return 'MuSE'\n    elif 'SUBDP' in format_recs:\n        return 'Strelka'\n    elif 'PL' in format_recs and 'GT' in format_recs:\n        return 'haplotypers'\n    else:\n        raise ValueError('Could not infer the identity of the caller.')\n\n\ndef main(var_suppl, bam_dict, caller):\n\n    if caller == 'TNHaplotyper' or caller == 'MuTect':\n        extract_stats = parse_tnhap_mutect_rec\n    elif caller == 'MuSE':\n        extract_stats = parse_muse_rec\n    elif caller == 'VarScan':\n        extract_stats = parse_varscan_rec\n    elif caller == 'VarDict':\n        extract_stats = parse_vardict_rec\n    elif caller == 'Strelka':\n        extract_stats = parse_strelka_rec\n    elif caller == 'haplotypers':\n        extract_stats = parse_haplotypers_rec\n    else:\n        raise ValueError('Unknown caller')\n\n    writers = {key: open(key + '.vaf', 'w') for key in bam_dict}  # there won't be any headers in the output files\n\n    for rec in var_suppl:\n\n        if not rec.is_snp:\n            continue\n            \n        if caller == 'Strelka':\n            ref = rec.REF\n            alt = rec.ALT\n        \n        for sample in rec.samples:\n\n            # First, try to handle the case of having VAF in FREQ, ALT allele depth in AD, and total depth in DP\n            try:\n                if caller == 'Strelka':\n                    vaf, read_counts = extract_stats(sample,ref,alt)\n                else:\n                    vaf, read_counts = extract_stats(sample)\n            except (AttributeError, ValueError):\n                vaf, read_counts = None, None\n\n            # If that fails, we're doing the counting\n            if vaf is None:\n\n                read_counts = [0, 0]\n                bam_suppl = bam_dict[sample.sample]\n                for read in bam_suppl.fetch(rec.CHROM, rec.start, rec.end):\n                    if read.is_duplicate:\n                        continue\n                    pos = rec.start - read.reference_start\n                    if pos < read.query_alignment_start or pos >= read.query_alignment_end:\n                        continue  # we're in soft-clipped territory\n                    base = read.query_sequence[pos]\n                    if base == rec.REF:\n                        read_counts[0] += 1\n                    elif base in rec.ALT:\n                        read_counts[1] += 1\n\n                if read_counts[1] == 0:\n                    vaf = 0.00\n                else:\n                    vaf = float(read_counts[1]) / sum(read_counts) * 100\n            \n            if vaf != 0:\n                writer = writers[sample.sample]\n                # Important: we're assuming here SciClone expects 1-based indexing\n                writer.write('{}\\t{}\\t{}\\t{}\\t{}\\n'.format(rec.CHROM, rec.POS, read_counts[0], read_counts[1], vaf))\n\nif __name__ == '__main__':\n\n    parser = argparse.ArgumentParser(description=\"\"\"\n    Perform conversion of a VCF to a variant allele frequency file required by SciClone.\n\n    The script requires that an indexed BAM file is supplied for each sample from the VCF.\n    Name of the sample must be contained in the name of the respective BAM file, otherwise, the script will fail.\"\"\")\n    parser.add_argument('--vcf', dest='vcf', required=True, type=str)\n    parser.add_argument('--bams', dest='bams', type=str)\n    args = parser.parse_args()\n    if args.bams:\n        args.bams = args.bams.split(',')\n    \n    suppl = vcf.Reader(filename=args.vcf)  # this should handle gzipped input out-of-the-box\n    rec = suppl.next()\n    caller = sniff_out_caller(rec.samples[0])\n    samples = [sample.sample for sample in rec.samples]\n    if (len(samples) != 1):\n        if len(samples) != len(args.bams):\n            sys.stderr.write('Number of samples in the VCF does not match the number of BAM files provided.')\n            sys.exit(1)\n\n    bams = {}\n    \n    for sample in samples:\n        if len(samples) > 1:\n            matching_bam = [bam for bam in args.bams if sample in bam.split('/')[-1]]\n            if len(matching_bam) == 0:\n                sys.stderr.write('No matching BAM file found for sample: ' + sample)\n                sys.exit(1)\n            elif len(matching_bam) > 1:\n                sys.stderr.write('Could not match sample ' + sample + ' to a single BAM unambiguously.')\n                sys.exit(1)\n\n            matching_bam = matching_bam[0]\n        #source_dir = '/'.join(matching_bam.split('/')[:-1])\n        #dir_content = os.listdir(source_dir) if source_dir else os.listdir('.')\n        #if not (matching_bam[:-3] + 'bai' in dir_content) and not (matching_bam + '.bai' in dir_content):\n        #    print 'Missing index file for', matching_bam\n        #    sys.exit(1)\n        \n            bams[sample] = pysam.AlignmentFile(matching_bam, 'rb')\n        else: \n            bams[sample] = None\n    var_suppl = vcf.Reader(filename=args.vcf)  # reopen the thing so we seek back to the first record (not particularly elegant)\n\n    main(var_suppl=var_suppl, bam_dict=bams, caller=caller)"
              },
              {
                "filename": "regions_to_exclude.py",
                "fileContent": "import argparse\n\nparser = argparse.ArgumentParser(description='This scripts takes a file with VAF information and produces a file with lines only above a certain VAF threshold.')\nparser.add_argument('-i','--input', help='Input VAF file', required=True)\nparser.add_argument('-t','--threshold', type=float, default=70, help='VAF threshold. All input file lines with VAFs above this value will be written to the output file. Input should be a float number between 0 and 100. ', required=False)\n\nargs = vars(parser.parse_args())\n\nvaf_file = args['input']\nthreshold = args['threshold']\noutput_file = ('.').join(vaf_file.split('.')[0:-1]) + '.exclude.txt'\np = ''\nk = 0\nwith open(vaf_file) as f:\n    for line in f:\n        x = line.split('\\t')\n        if k==0:\n            chr_name = x[0]\n            k = 1\n        if float(x[4])>threshold:\n            p += x[0] + '\\t' + x[1] + '\\t' + x[1] + '\\n'\nif p=='':\n    p = chr_name + '\\t' + '1' + '\\t' + '1' + '\\n'\nwith open(output_file,\"w\") as f:\n    f.write(p)"
              }
            ]
          },
          {
            "requirements": [
              {
                "class": "DockerRequirement",
                "dockerPull": "rabix/js-engine"
              }
            ],
            "id": "#cwl-js-engine",
            "class": "ExpressionEngineRequirement"
          }
        ],
        "sbg:sbgMaintained": false,
        "sbg:latestRevision": 22,
        "cwlVersion": "sbg:draft-2",
        "sbg:image_url": null,
        "inputs": [
          {
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--vcf",
              "position": 0
            },
            "sbg:category": "Inputs",
            "description": "A VCF file with one or more sample columns.",
            "id": "#vcf",
            "sbg:fileTypes": "VCF",
            "type": [
              "File"
            ],
            "label": "VCF file"
          },
          {
            "inputBinding": {
              "itemSeparator": ",",
              "secondaryFiles": [
                ".bai"
              ],
              "prefix": "--bams",
              "separate": true,
              "sbg:cmdInclude": true,
              "position": 1
            },
            "sbg:category": "Inputs",
            "description": "Indexed BAM files, one for each sample in the provided VCF, if there are multiple VCFs.",
            "id": "#bams",
            "sbg:fileTypes": "BAM",
            "type": [
              "null",
              {
                "items": "File",
                "type": "array"
              }
            ],
            "label": "BAM file(s)"
          },
          {
            "sbg:category": "Inputs",
            "sbg:toolDefaultValue": "70",
            "description": "Lines with VAF values above this threshold will be written to the file with regions to exclude from SciClone analysis.",
            "id": "#vaf_threshold",
            "type": [
              "null",
              "float"
            ],
            "label": "VAF threshold"
          }
        ],
        "sbg:modifiedBy": "uros_sipetic",
        "successCodes": [],
        "baseCommand": [
          "python",
          "vcf_parser.py"
        ]
      },
      "inputs": [
        {
          "id": "#SBG_SciClone_VCF_parser.vcf",
          "source": [
            "#VCFtools_Merge.output_file"
          ]
        },
        {
          "id": "#SBG_SciClone_VCF_parser.bams",
          "source": [
            "#bams"
          ]
        },
        {
          "id": "#SBG_SciClone_VCF_parser.vaf_threshold",
          "source": [
            "#vaf_threshold"
          ]
        }
      ]
    }
  ],
  "sbg:createdOn": 1485959785,
  "sbg:project": "uros_sipetic/bms-tumor-heterogeneity",
  "outputs": [
    {
      "sbg:x": 1329.3001708984375,
      "sbg:includeInPorts": true,
      "required": false,
      "id": "#sciclone_plots",
      "sbg:y": 64.15945434570312,
      "sbg:fileTypes": "PDF,GIF",
      "type": [
        "null",
        {
          "items": "File",
          "type": "array",
          "name": "sciclone_plots"
        }
      ],
      "source": [
        "#SciClone_1_1.sciclone_plots"
      ],
      "label": "SciClone plots"
    },
    {
      "sbg:x": 1815.936767578125,
      "sbg:includeInPorts": true,
      "required": false,
      "id": "#clonevol_plots",
      "sbg:y": 198.33424377441406,
      "sbg:fileTypes": "PDF,PNG",
      "type": [
        "null",
        {
          "items": "File",
          "type": "array",
          "name": "clonevol_plots"
        }
      ],
      "source": [
        "#ClonEvol_0_1.clonevol_plots"
      ],
      "label": "ClonEvol plots"
    },
    {
      "sbg:x": 2016.981689453125,
      "sbg:includeInPorts": true,
      "required": false,
      "id": "#fishplot_plots",
      "sbg:y": 369.07855224609375,
      "sbg:fileTypes": "PDF",
      "type": [
        "null",
        "File"
      ],
      "source": [
        "#Fishplot_0_3.fishplot_plots"
      ],
      "label": "Fishplot plots"
    },
    {
      "sbg:x": 1396.93310546875,
      "sbg:includeInPorts": true,
      "required": false,
      "id": "#clusters",
      "sbg:y": 441.4258117675781,
      "sbg:fileTypes": "TXT,CLUSTERS",
      "type": [
        "null",
        "File"
      ],
      "source": [
        "#SciClone_1_1.clusters"
      ],
      "label": "SciClone clusters"
    },
    {
      "sbg:x": 1331.000177665639,
      "sbg:includeInPorts": true,
      "required": false,
      "id": "#clusterSummary",
      "sbg:y": 568.8572164846952,
      "sbg:fileTypes": "TXT,SUMMARY",
      "type": [
        "null",
        {
          "items": "File",
          "type": "array"
        }
      ],
      "source": [
        "#SciClone_1_1.clusterSummary"
      ],
      "label": "SciClone cluster summary"
    },
    {
      "sbg:x": 1395.1597900390625,
      "sbg:includeInPorts": true,
      "required": false,
      "id": "#purity",
      "sbg:y": 196.86553955078125,
      "sbg:fileTypes": "TXT",
      "type": [
        "null",
        "File"
      ],
      "source": [
        "#SciClone_1_1.purity"
      ],
      "label": "Estimated tumor purity"
    }
  ],
  "sbg:appVersion": [
    "sbg:draft-2"
  ],
  "id": "https://api.sbgenomics.com/v2/apps/uros_sipetic/bms-tumor-heterogeneity/tumor-heterogeneity-sciclone-based-workflow/17/raw/",
  "sbg:categories": [
    "Tumor-heterogeneity",
    "Tumor-sub-clonality",
    "Tumor-purity"
  ],
  "hints": [],
  "sbg:modifiedOn": 1494516394,
  "label": "Tumor Heterogeneity SciClone-based workflow",
  "sbg:license": "GNU General Public License v3.0 only, Apache License 2.0",
  "sbg:validationErrors": [],
  "sbg:links": [
    {
      "id": "https://github.com/genome/sciclone",
      "label": "SciClone Homepage"
    },
    {
      "id": "http://journals.plos.org/ploscompbiol/article/asset?id=10.1371%2Fjournal.pcbi.1003665.PDF",
      "label": "SciClone Publication"
    },
    {
      "id": "https://github.com/hdng/clonevol",
      "label": "ClonEvol Homepage"
    },
    {
      "id": "https://github.com/chrisamiller/fishplot",
      "label": "Fishplot Homepage"
    },
    {
      "id": "http://biorxiv.org/content/biorxiv/early/2016/06/15/059055.full.pdf",
      "label": "Fishplot Publication"
    }
  ],
  "sbg:canvas_y": 91,
  "sbg:toolkit": "",
  "sbg:toolkitVersion": "",
  "sbg:revisionNotes": "Copy of uros_sipetic/bms-tumor-heterogeneity-dev/sciclone-workflow/56",
  "sbg:id": "uros_sipetic/bms-tumor-heterogeneity/tumor-heterogeneity-sciclone-based-workflow/17",
  "sbg:contributors": [
    "uros_sipetic"
  ],
  "requirements": [],
  "sbg:toolAuthor": "Seven Bridges Genomics",
  "class": "Workflow",
  "sbg:latestRevision": 17,
  "cwlVersion": "sbg:draft-2",
  "sbg:image_url": "https://brood.sbgenomics.com/static/uros_sipetic/bms-tumor-heterogeneity/tumor-heterogeneity-sciclone-based-workflow/17.png",
  "sbg:revision": 17,
  "sbg:modifiedBy": "uros_sipetic",
  "inputs": [
    {
      "sbg:x": 1447.5692138671875,
      "id": "#known_cancer_genes",
      "sbg:y": 63.823638916015625,
      "sbg:fileTypes": "VCF,TXT",
      "type": [
        "null",
        "File"
      ],
      "label": "Known cancer genes"
    },
    {
      "sbg:x": 1449.8828125,
      "id": "#gtf",
      "sbg:y": 567.1961669921875,
      "sbg:fileTypes": "GTF",
      "type": [
        "null",
        "File"
      ],
      "label": "GTF file"
    },
    {
      "sbg:x": 929.510151982527,
      "id": "#copyNumberCalls",
      "sbg:y": 441.0005033489208,
      "sbg:fileTypes": "CNV,CNS,TXT",
      "type": [
        "null",
        {
          "items": "File",
          "type": "array",
          "name": "copyNumberCalls"
        }
      ],
      "label": "Copy number calls"
    },
    {
      "sbg:x": -401.696140455163,
      "id": "#input_files",
      "sbg:y": 309.62996773097825,
      "sbg:fileTypes": "VCF",
      "type": [
        {
          "items": "File",
          "type": "array"
        }
      ],
      "label": "VCF files"
    },
    {
      "sbg:x": 737,
      "secondaryFiles": [
        ".bai"
      ],
      "id": "#bams",
      "sbg:y": 441.478271484375,
      "sbg:fileTypes": "BAM",
      "type": [
        "null",
        {
          "items": "File",
          "type": "array"
        }
      ],
      "label": "Tumor BAM files"
    },
    {
      "sbg:category": "Arguments",
      "sbg:toolDefaultValue": "TRUE",
      "description": "Boolean argument to specify preference of whether or not to use variants on sex chromosomes in the clustering steps of the tool.",
      "id": "#useSexChrs",
      "type": [
        "null",
        {
          "type": "enum",
          "name": "useSexChrs",
          "symbols": [
            "TRUE",
            "FALSE"
          ]
        }
      ],
      "label": "Use sex chromosomes"
    },
    {
      "sbg:stageInput": null,
      "sbg:category": "Arguments",
      "sbg:toolDefaultValue": "100",
      "description": "Threshold used for excluding low-depth variants.",
      "id": "#minimumDepth",
      "type": [
        "null",
        "int"
      ],
      "label": "Minimum depth"
    },
    {
      "sbg:stageInput": null,
      "sbg:category": "Arguments",
      "sbg:toolDefaultValue": "0.25",
      "description": "In order to identify cleanly copy-number neutral regions, sciClone only considers sites with a copy number of 2.0 +/- this value. For example, if set to 0.25 (which is the default value), regions at 2.20 will be considered cn-neutral and regions at 2.30 will be not.",
      "id": "#copyNumberMargins",
      "type": [
        "null",
        "float"
      ],
      "label": "Copy Number Margins"
    },
    {
      "sbg:stageInput": null,
      "sbg:category": "Arguments",
      "description": "This is a boolean argument which you should specify only if your CN data came from the Control-FREEC tool, in order to parse the resulting files properly.",
      "id": "#control_freec",
      "type": [
        "null",
        "boolean"
      ],
      "label": "Control-FREEC for CN data"
    },
    {
      "id": "#cnv_kit",
      "sbg:category": "Arguments",
      "type": [
        "null",
        "boolean"
      ],
      "description": "This is a boolean argument which you should specify only if your CN data came from the CNVkit tool, in order to parse the resulting files properly.",
      "label": "CNVkit for CN data"
    },
    {
      "sbg:stageInput": null,
      "sbg:category": "Arguments",
      "sbg:toolDefaultValue": "False",
      "description": "Boolean argument specifying whether or not the copy number predictions are in log2 format (as opposed to being absolute copy number designations).",
      "id": "#cnCallsAreLog2",
      "type": [
        "null",
        "boolean"
      ],
      "label": "Copy numbers in log2 format"
    },
    {
      "sbg:stageInput": null,
      "sbg:category": "Arguments",
      "sbg:toolDefaultValue": "bmm",
      "description": "Use a different distribution for clustering. Currently supported options are 'bmm' for beta, 'gaussian.bmm' for gaussian and 'binomial.bmm' for binomial.",
      "id": "#clusterMethod",
      "type": [
        "null",
        {
          "type": "enum",
          "name": "clusterMethod",
          "symbols": [
            "bmm",
            "gaussian.bmm",
            "binomial.bmm"
          ]
        }
      ],
      "label": "Cluster method"
    },
    {
      "sbg:category": "Inputs",
      "sbg:toolDefaultValue": "70",
      "description": "Lines with VAF values above this threshold will be written to the file with regions to exclude from SciClone analysis.",
      "id": "#vaf_threshold",
      "type": [
        "null",
        "float"
      ],
      "label": "VAF threshold"
    }
  ]
}